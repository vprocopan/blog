<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-11-08T09:29:22+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Vitalie Procopan’s Blog</title><subtitle></subtitle><entry><title type="html">CKA killer.sh dump2</title><link href="http://localhost:4000/2024/06/09/CKA-2.html" rel="alternate" type="text/html" title="CKA killer.sh dump2" /><published>2024-06-09T00:00:00+03:00</published><updated>2024-06-09T00:00:00+03:00</updated><id>http://localhost:4000/2024/06/09/CKA-2</id><content type="html" xml:base="http://localhost:4000/2024/06/09/CKA-2.html"><![CDATA[<hr />
<p>author: Vitalie Procopan
date: 2024-06-09 09:35:00
changed: 2024-06-09 09:35:00
—</p>

<p><strong>CKA Simulator Kubernetes 1.28</strong></p>

<p><a href="https://killer.sh/">[https://killer.sh]{.underline}</a></p>

<p><strong>Pre Setup</strong></p>

<p>Once you've gained access to your terminal it might be wise to spend ~1 minute to setup your environment. You could set these:</p>

<p>alias k=kubectl                         # will already be pre-configured</p>

<p>export do="--dry-run=client -o yaml"    # k create deploy nginx --image=nginx $do</p>

<p>export now="--force --grace-period 0"   # k delete pod x $now</p>

<p><strong>Vim</strong></p>

<p>The following settings will already be configured in your real exam environment in ~/.vimrc. But it can never hurt to be able to type these down:</p>

<p>set tabstop=2</p>

<p>set expandtab</p>

<p>set shiftwidth=2</p>

<p>More setup suggestions are in the <strong>tips section</strong>.</p>

<p> </p>

<p> </p>

<p><strong>Question 1 | Contexts</strong></p>

<p> </p>

<p>You have access to multiple clusters from your main terminal through kubectl contexts. Write all those context names into /opt/course/1/contexts.</p>

<p>Next write a command to display the current context into /opt/course/1/context_default_kubectl.sh, the command should use kubectl.</p>

<p>Finally write a second command doing the same thing into /opt/course/1/context_default_no_kubectl.sh, but without the use of kubectl.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>Maybe the fastest way is just to run:</p>

<p>k config get-contexts # copy manually</p>

<p>k config get-contexts -o name &gt; /opt/course/1/contexts</p>

<p>Or using jsonpath:</p>

<p>k config view -o yaml # overview</p>

<p>k config view -o jsonpath="{.contexts[*].name}"</p>

<p>k config view -o jsonpath="{.contexts[*].name}" | tr " " "\n" # new lines</p>

<p>k config view -o jsonpath="{.contexts[*].name}" | tr " " "\n" &gt; /opt/course/1/contexts</p>

<p>The content should then look like:</p>

<p># /opt/course/1/contexts</p>

<p>k8s-c1-H</p>

<p>k8s-c2-AC</p>

<p>k8s-c3-CCC</p>

<p>Next create the first command:</p>

<p># /opt/course/1/context_default_kubectl.sh</p>

<p>kubectl config current-context</p>

<p>➜ sh /opt/course/1/context_default_kubectl.sh</p>

<p>k8s-c1-H</p>

<p>And the second one:</p>

<p># /opt/course/1/context_default_no_kubectl.sh</p>

<p>cat ~/.kube/config | grep current</p>

<p>➜ sh /opt/course/1/context_default_no_kubectl.sh</p>

<p>current-context: k8s-c1-H</p>

<p>In the real exam you might need to filter and find information from bigger lists of resources, hence knowing a little jsonpath and simple bash filtering will be helpful.</p>

<p>The second command could also be improved to:</p>

<p># /opt/course/1/context_default_no_kubectl.sh</p>

<p>cat ~/.kube/config | grep current | sed -e "s/current-context: //"</p>

<p> </p>

<p> </p>

<p><strong>Question 2 | Schedule Pod on Controlplane Nodes</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a single <em>Pod</em> of image httpd:2.4.41-alpine in <em>Namespace</em> default. The <em>Pod</em> should be named pod1 and the container should be named pod1-container. This <em>Pod</em> should <strong>only</strong> be scheduled on controlplane nodes. Do not add new labels to any nodes.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we find the controlplane node(s) and their taints:</p>

<p>k get node # find controlplane node</p>

<p>k describe node cluster1-controlplane1 | grep Taint -A1 # get controlplane node taints</p>

<p>k get node cluster1-controlplane1 --show-labels # get controlplane node labels</p>

<p> </p>

<p>Next we create the <em>Pod</em> template:</p>

<p># check the export on the very top of this document so we can use $do</p>

<p>k run pod1 --image=httpd:2.4.41-alpine $do &gt; 2.yaml</p>

<p>vim 2.yaml</p>

<p>Perform the necessary changes manually. Use the Kubernetes docs and search for example for tolerations and nodeSelector to find examples:</p>

<p># 2.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: pod1</p>

<p>name: pod1</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: httpd:2.4.41-alpine</p>

<p>  name: pod1-container                       # change</p>

<p>  resources: {}</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>tolerations:                                 # add</p>

<p>- effect: NoSchedule                         # add</p>

<p>  key: node-role.kubernetes.io/control-plane # add</p>

<p>nodeSelector:                                # add</p>

<p>  node-role.kubernetes.io/control-plane: ""  # add</p>

<p>status: {}</p>

<p>Important here to add the toleration for running on controlplane nodes, but also the nodeSelector to make sure it only runs on controlplane nodes. If we only specify a toleration the <em>Pod</em> can be scheduled on controlplane or worker nodes.</p>

<p>Now we create it:</p>

<p>k -f 2.yaml create</p>

<p>Let's check if the pod is scheduled:</p>

<p>➜ k get pod pod1 -o wide</p>

<p>NAME   READY   STATUS   RESTARTS   ...   NODE                     NOMINATED NODE</p>

<p>pod1   1/1     Running   0         ...   cluster1-controlplane1   &lt;none&gt;        </p>

<p> </p>

<p> </p>

<p><strong>Question 3 | Scale down StatefulSet</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There are two <em>Pods</em> named o3db-* in <em>Namespace</em> project-c13. C13 management asked you to scale the <em>Pods</em> down to one replica to save resources.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>If we check the <em>Pods</em> we see two replicas:</p>

<p>➜ k -n project-c13 get pod | grep o3db</p>

<p>o3db-0                                 1/1     Running   0         52s</p>

<p>o3db-1                                 1/1     Running   0         42s</p>

<p>From their name it looks like these are managed by a <em>StatefulSet</em>. But if we're not sure we could also check for the most common resources which manage <em>Pods</em>:</p>

<p>➜ k -n project-c13 get deploy,ds,sts | grep o3db</p>

<p>statefulset.apps/o3db   2/2     2m56s</p>

<p>Confirmed, we have to work with a <em>StatefulSet</em>. To find this out we could also look at the <em>Pod</em> labels:</p>

<p>➜ k -n project-c13 get pod --show-labels | grep o3db</p>

<p>o3db-0                                 1/1     Running   0         3m29s   app=nginx,controller-revision-hash=o3db-5fbd4bb9cc,statefulset.kubernetes.io/pod-name=o3db-0</p>

<p>o3db-1                                 1/1     Running   0         3m19s   app=nginx,controller-revision-hash=o3db-5fbd4bb9cc,statefulset.kubernetes.io/pod-name=o3db-1</p>

<p>To fulfil the task we simply run:</p>

<p>➜ k -n project-c13 scale sts o3db --replicas 1</p>

<p>statefulset.apps/o3db scaled</p>

<p>➜ k -n project-c13 get sts o3db</p>

<p>NAME   READY   AGE</p>

<p>o3db   1/1     4m39s</p>

<p>C13 Mangement is happy again.</p>

<p> </p>

<p> </p>

<p><strong>Question 4 | Pod Ready if Service is reachable</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Do the following in <em>Namespace</em> default. Create a single <em>Pod</em> named ready-if-service-ready of image nginx:1.16.1-alpine. Configure a LivenessProbe which simply executes command true. Also configure a ReadinessProbe which does check if the url http://service-am-i-ready:80 is reachable, you can use wget -T2 -O- http://service-am-i-ready:80 for this. Start the <em>Pod</em> and confirm it isn't ready because of the ReadinessProbe.</p>

<p>Create a second <em>Pod</em> named am-i-ready of image nginx:1.16.1-alpine with label id: cross-server-ready. The already existing <em>Service</em> service-am-i-ready should now have that second <em>Pod</em> as endpoint.</p>

<p>Now the first <em>Pod</em> should be in ready state, confirm that.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>It's a bit of an anti-pattern for one <em>Pod</em> to check another <em>Pod</em> for being ready using probes, hence the normally available readinessProbe.httpGet doesn't work for absolute remote urls. Still the workaround requested in this task should show how probes and <em>Pod</em>&lt;-&gt;<em>Service</em> communication works.</p>

<p>First we create the first <em>Pod</em>:</p>

<p>k run ready-if-service-ready --image=nginx:1.16.1-alpine $do &gt; 4_pod1.yaml</p>

<p>vim 4_pod1.yaml</p>

<p>Next perform the necessary additions manually:</p>

<p># 4_pod1.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: ready-if-service-ready</p>

<p>name: ready-if-service-ready</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.16.1-alpine</p>

<p>  name: ready-if-service-ready</p>

<p>  resources: {}</p>

<p>  livenessProbe:                                      # add from here</p>

<p>    exec:</p>

<p>      command:</p>

<p>      - 'true'</p>

<p>  readinessProbe:</p>

<p>    exec:</p>

<p>      command:</p>

<p>      - sh</p>

<p>      - -c</p>

<p>      - 'wget -T2 -O- http://service-am-i-ready:80'   # to here</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p>Then create the <em>Pod</em>:</p>

<p>k -f 4_pod1.yaml create</p>

<p>And confirm it's in a non-ready state:</p>

<p>➜ k get pod ready-if-service-ready</p>

<p>NAME                     READY   STATUS   RESTARTS   AGE</p>

<p>ready-if-service-ready   0/1     Running   0         7s</p>

<p>We can also check the reason for this using describe:</p>

<p>➜ k describe pod ready-if-service-ready</p>

<p>...</p>

<p>Warning Unhealthy 18s   kubelet, cluster1-node1 Readiness probe failed: Connecting to service-am-i-ready:80 (10.109.194.234:80)</p>

<p>wget: download timed out</p>

<p>Now we create the second <em>Pod</em>:</p>

<p>k run am-i-ready --image=nginx:1.16.1-alpine --labels="id=cross-server-ready"</p>

<p>The already existing <em>Service</em> service-am-i-ready should now have an <em>Endpoint</em>:</p>

<p>k describe svc service-am-i-ready</p>

<p>k get ep # also possible</p>

<p>Which will result in our first <em>Pod</em> being ready, just give it a minute for the Readiness probe to check again:</p>

<p>➜ k get pod ready-if-service-ready</p>

<p>NAME                     READY   STATUS   RESTARTS   AGE</p>

<p>ready-if-service-ready   1/1     Running   0         53s</p>

<p>Look at these <em>Pods</em> coworking together!</p>

<p> </p>

<p> </p>

<p><strong>Question 5 | Kubectl sorting</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There are various <em>Pods</em> in all namespaces. Write a command into /opt/course/5/find_pods.sh which lists all <em>Pods</em> sorted by their AGE (metadata.creationTimestamp).</p>

<p>Write a second command into /opt/course/5/find_pods_uid.sh which lists all <em>Pods</em> sorted by field metadata.uid. Use kubectl sorting for both commands.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>A good resources here (and for many other things) is the kubectl-cheat-sheet. You can reach it fast when searching for "cheat sheet" in the Kubernetes docs.</p>

<p># /opt/course/5/find_pods.sh</p>

<p>kubectl get pod -A --sort-by=.metadata.creationTimestamp</p>

<p>And to execute:</p>

<p>➜ sh /opt/course/5/find_pods.sh</p>

<p>NAMESPACE         NAME                                             ...         AGE</p>

<p>kube-system       kube-scheduler-cluster1-controlplane1           ...         63m</p>

<p>kube-system       etcd-cluster1-controlplane1                     ...         63m</p>

<p>kube-system       kube-apiserver-cluster1-controlplane1           ...         63m</p>

<p>kube-system       kube-controller-manager-cluster1-controlplane1   ...         63m</p>

<p>...</p>

<p>For the second command:</p>

<p># /opt/course/5/find_pods_uid.sh</p>

<p>kubectl get pod -A --sort-by=.metadata.uid</p>

<p>And to execute:</p>

<p>➜ sh /opt/course/5/find_pods_uid.sh</p>

<p>NAMESPACE         NAME                                     ...         AGE</p>

<p>kube-system       coredns-5644d7b6d9-vwm7g                 ...         68m</p>

<p>project-c13       c13-3cc-runner-heavy-5486d76dd4-ddvlt     ...         63m</p>

<p>project-hamster   web-hamster-shop-849966f479-278vp         ...         63m</p>

<p>project-c13       c13-3cc-web-646b6c8756-qsg4b             ...         63m</p>

<p> </p>

<p> </p>

<p><strong>Question 6 | Storage, PV, PVC, Pod volume</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a new <em>PersistentVolume</em> named safari-pv. It should have a capacity of <em>2Gi</em>, accessMode <em>ReadWriteOnce</em>, hostPath /Volumes/Data and no storageClassName defined.</p>

<p>Next create a new <em>PersistentVolumeClaim</em> in <em>Namespace</em> project-tiger named safari-pvc . It should request <em>2Gi</em> storage, accessMode <em>ReadWriteOnce</em> and should not define a storageClassName. The <em>PVC</em> should bound to the <em>PV</em> correctly.</p>

<p>Finally create a new <em>Deployment</em> safari in <em>Namespace</em> project-tiger which mounts that volume at /tmp/safari-data. The <em>Pods</em> of that <em>Deployment</em> should be of image httpd:2.4.41-alpine.</p>

<p> </p>

<p><strong>Answer</strong></p>

<p>vim 6_pv.yaml</p>

<p>Find an example from <a href="https://kubernetes.io/docs">[https://kubernetes.io/docs]{.underline}</a> and alter it:</p>

<p># 6_pv.yaml</p>

<p>kind: PersistentVolume</p>

<p>apiVersion: v1</p>

<p>metadata:</p>

<p>name: safari-pv</p>

<p>spec:</p>

<p>capacity:</p>

<p>storage: 2Gi</p>

<p>accessModes:</p>

<p>- ReadWriteOnce</p>

<p>hostPath:</p>

<p>path: "/Volumes/Data"</p>

<p>Then create it:</p>

<p>k -f 6_pv.yaml create</p>

<p>Next the <em>PersistentVolumeClaim</em>:</p>

<p>vim 6_pvc.yaml</p>

<p>Find an example from <a href="https://kubernetes.io/docs">[https://kubernetes.io/docs]{.underline}</a> and alter it:</p>

<p># 6_pvc.yaml</p>

<p>kind: PersistentVolumeClaim</p>

<p>apiVersion: v1</p>

<p>metadata:</p>

<p>name: safari-pvc</p>

<p>namespace: project-tiger</p>

<p>spec:</p>

<p>accessModes:</p>

<p>  - ReadWriteOnce</p>

<p>resources:</p>

<p>  requests:</p>

<p>    storage: 2Gi</p>

<p>Then create:</p>

<p>k -f 6_pvc.yaml create</p>

<p>And check that both have the status Bound:</p>

<p>➜ k -n project-tiger get pv,pvc</p>

<p>NAME                         CAPACITY ... STATUS   CLAIM                   ...</p>

<p>persistentvolume/safari-pv   2Gi       ... Bound   project-tiger/safari-pvc ...</p>

<p>NAME                               STATUS   VOLUME     CAPACITY ...</p>

<p>persistentvolumeclaim/safari-pvc   Bound   safari-pv   2Gi     ...</p>

<p>Next we create a <em>Deployment</em> and mount that volume:</p>

<p>k -n project-tiger create deploy safari \</p>

<p>--image=httpd:2.4.41-alpine $do &gt; 6_dep.yaml</p>

<p>vim 6_dep.yaml</p>

<p>Alter the yaml to mount the volume:</p>

<p># 6_dep.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: Deployment</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  app: safari</p>

<p>name: safari</p>

<p>namespace: project-tiger</p>

<p>spec:</p>

<p>replicas: 1</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    app: safari</p>

<p>strategy: {}</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      app: safari</p>

<p>  spec:</p>

<p>    volumes:      # add</p>

<p>    - name: data      # add</p>

<p>      persistentVolumeClaim:      # add</p>

<p>        claimName: safari-pvc                     # add</p>

<p>    containers:</p>

<p>    - image: httpd:2.4.41-alpine</p>

<p>      name: container</p>

<p>      volumeMounts:      # add</p>

<p>      - name: data      # add</p>

<p>        mountPath: /tmp/safari-data      # add</p>

<p>k -f 6_dep.yaml create</p>

<p>We can confirm it's mounting correctly:</p>

<p>➜ k -n project-tiger describe pod safari-5cbf46d6d-mjhsb | grep -A2 Mounts:  </p>

<p>  Mounts:</p>

<p>    /tmp/safari-data from data (rw) # there it is</p>

<p>    /var/run/secrets/kubernetes.io/serviceaccount from default-token-n2sjj (ro)</p>

<p> </p>

<p> </p>

<p><strong>Question 7 | Node and Pod Resource Usage</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>The metrics-server has been installed in the cluster. Your college would like to know the kubectl commands to:</p>

<ol>
  <li>
    <p>show <em>Nodes</em> resource usage</p>
  </li>
  <li>
    <p>show <em>Pods</em> and their containers resource usage</p>
  </li>
</ol>

<p>Please write the commands into /opt/course/7/node.sh and /opt/course/7/pod.sh.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>The command we need to use here is top:</p>

<p>➜ k top -h</p>

<p>Display Resource (CPU/Memory/Storage) usage.</p>

<p>The top command allows you to see the resource consumption for nodes or pods.</p>

<p>This command requires Metrics Server to be correctly configured and working on the server.</p>

<p>Available Commands:</p>

<p>node       Display Resource (CPU/Memory/Storage) usage of nodes</p>

<p>pod         Display Resource (CPU/Memory/Storage) usage of pods</p>

<p>We see that the metrics server provides information about resource usage:</p>

<p>➜ k top node</p>

<p>NAME               CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%  </p>

<p>cluster1-controlplane1   178m         8%     1091Mi         57%      </p>

<p>cluster1-node1   66m         6%     834Mi           44%      </p>

<p>cluster1-node2   91m         9%     791Mi           41%</p>

<p>We create the first file:</p>

<p># /opt/course/7/node.sh</p>

<p>kubectl top node</p>

<p>For the second file we might need to check the docs again:</p>

<p>➜ k top pod -h</p>

<p>Display Resource (CPU/Memory/Storage) usage of pods.</p>

<p>...</p>

<p>Namespace in current context is ignored even if specified with --namespace.</p>

<p>    --containers=false: If present, print usage of containers within a pod.</p>

<p>    --no-headers=false: If present, print output without headers.</p>

<p>...</p>

<p>With this we can finish this task:</p>

<p># /opt/course/7/pod.sh</p>

<p>kubectl top pod --containers=true</p>

<p> </p>

<p> </p>

<p><strong>Question 8 | Get Controlplane Information</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Ssh into the controlplane node with ssh cluster1-controlplane1. Check how the controlplane components kubelet, kube-apiserver, kube-scheduler, kube-controller-manager and etcd are started/installed on the controlplane node. Also find out the name of the DNS application and how it's started/installed on the controlplane node.</p>

<p>Write your findings into file /opt/course/8/controlplane-components.txt. The file should be structured like:</p>

<p># /opt/course/8/controlplane-components.txt</p>

<p>kubelet: [TYPE]</p>

<p>kube-apiserver: [TYPE]</p>

<p>kube-scheduler: [TYPE]</p>

<p>kube-controller-manager: [TYPE]</p>

<p>etcd: [TYPE]</p>

<p>dns: [TYPE] [NAME]</p>

<p>Choices of [TYPE] are: not-installed, process, static-pod, pod</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>We could start by finding processes of the requested components, especially the kubelet at first:</p>

<p>➜ ssh cluster1-controlplane1</p>

<p>root@cluster1-controlplane1:~# ps aux | grep kubelet # shows kubelet process</p>

<p>We can see which components are controlled via systemd looking at /etc/systemd/system directory:</p>

<p>➜ root@cluster1-controlplane1:~# find /etc/systemd/system/ | grep kube</p>

<p>/etc/systemd/system/kubelet.service.d</p>

<p>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</p>

<p>/etc/systemd/system/multi-user.target.wants/kubelet.service</p>

<p>➜ root@cluster1-controlplane1:~# find /etc/systemd/system/ | grep etcd</p>

<p>This shows kubelet is controlled via systemd, but no other service named kube nor etcd. It seems that this cluster has been setup using kubeadm, so we check in the default manifests directory:</p>

<p>➜ root@cluster1-controlplane1:~# find /etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p>/etc/kubernetes/manifests/etcd.yaml</p>

<p>/etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p>/etc/kubernetes/manifests/kube-scheduler.yaml</p>

<p>(The kubelet could also have a different manifests directory specified via parameter --pod-manifest-path in it's systemd startup config)</p>

<p>This means the main 4 controlplane services are setup as static <em>Pods</em>. Actually, let's check all <em>Pods</em> running on in the kube-system <em>Namespace</em> on the controlplane node:</p>

<p>➜ root@cluster1-controlplane1:~# kubectl -n kube-system get pod -o wide | grep controlplane1</p>

<p>coredns-5644d7b6d9-c4f68                           1/1     Running           ...   cluster1-controlplane1</p>

<p>coredns-5644d7b6d9-t84sc                           1/1     Running           ...   cluster1-controlplane1</p>

<p>etcd-cluster1-controlplane1                         1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-apiserver-cluster1-controlplane1               1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-controller-manager-cluster1-controlplane1     1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-proxy-q955p                                   1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-scheduler-cluster1-controlplane1               1/1     Running           ...   cluster1-controlplane1</p>

<p>weave-net-mwj47                                     2/2     Running           ...   cluster1-controlplane1</p>

<p>There we see the 5 static pods, with -cluster1-controlplane1 as suffix.</p>

<p>We also see that the dns application seems to be coredns, but how is it controlled?</p>

<p>➜ root@cluster1-controlplane1$ kubectl -n kube-system get ds</p>

<p>NAME         DESIRED   CURRENT   ...   NODE SELECTOR           AGE</p>

<p>kube-proxy   3         3         ...   kubernetes.io/os=linux   155m</p>

<p>weave-net   3         3         ...   &lt;none&gt;                   155m</p>

<p>➜ root@cluster1-controlplane1$ kubectl -n kube-system get deploy</p>

<p>NAME     READY   UP-TO-DATE   AVAILABLE   AGE</p>

<p>coredns   2/2     2           2           155m</p>

<p>Seems like coredns is controlled via a <em>Deployment</em>. We combine our findings in the requested file:</p>

<p># /opt/course/8/controlplane-components.txt</p>

<p>kubelet: process</p>

<p>kube-apiserver: static-pod</p>

<p>kube-scheduler: static-pod</p>

<p>kube-controller-manager: static-pod</p>

<p>etcd: static-pod</p>

<p>dns: pod coredns</p>

<p>You should be comfortable investigating a running cluster, know different methods on how a cluster and its services can be setup and be able to troubleshoot and find error sources.</p>

<p> </p>

<p> </p>

<p><strong>Question 9 | Kill Scheduler, Manual Scheduling</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Ssh into the controlplane node with ssh cluster2-controlplane1. <strong>Temporarily</strong> stop the kube-scheduler, this means in a way that you can start it again afterwards.</p>

<p>Create a single <em>Pod</em> named manual-schedule of image httpd:2.4-alpine, confirm it's created but not scheduled on any node.</p>

<p>Now you're the scheduler and have all its power, manually schedule that <em>Pod</em> on node cluster2-controlplane1. Make sure it's running.</p>

<p>Start the kube-scheduler again and confirm it's running correctly by creating a second <em>Pod</em> named manual-schedule2 of image httpd:2.4-alpine and check if it's running on cluster2-node1.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Stop the Scheduler</strong></p>

<p>First we find the controlplane node:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster2-controlplane1   Ready   control-plane   26h   v1.28.2</p>

<p>cluster2-node1           Ready   &lt;none&gt;         26h   v1.28.2</p>

<p>Then we connect and check if the scheduler is running:</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep schedule</p>

<p>kube-scheduler-cluster2-controlplane1           1/1     Running   0         6s</p>

<p>Kill the Scheduler (temporarily):</p>

<p>➜ root@cluster2-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>➜ root@cluster2-controlplane1:~# mv kube-scheduler.yaml ..</p>

<p>And it should be stopped:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep schedule</p>

<p>➜ root@cluster2-controlplane1:~#</p>

<p> </p>

<p><strong>Create a <em>Pod</em></strong></p>

<p>Now we create the <em>Pod</em>:</p>

<p>k run manual-schedule --image=httpd:2.4-alpine</p>

<p>And confirm it has no node assigned:</p>

<p>➜ k get pod manual-schedule -o wide</p>

<p>NAME             READY   STATUS   ...   NODE     NOMINATED NODE</p>

<p>manual-schedule   0/1     Pending   ...   &lt;none&gt;   &lt;none&gt;        </p>

<p> </p>

<p><strong>Manually schedule the <em>Pod</em></strong></p>

<p>Let's play the scheduler now:</p>

<p>k get pod manual-schedule -o yaml &gt; 9.yaml</p>

<p># 9.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: "2020-09-04T15:51:02Z"</p>

<p>labels:</p>

<p>  run: manual-schedule</p>

<p>managedFields:</p>

<p>...</p>

<p>  manager: kubectl-run</p>

<p>  operation: Update</p>

<p>  time: "2020-09-04T15:51:02Z"</p>

<p>name: manual-schedule</p>

<p>namespace: default</p>

<p>resourceVersion: "3515"</p>

<p>selfLink: /api/v1/namespaces/default/pods/manual-schedule</p>

<p>uid: 8e9d2532-4779-4e63-b5af-feb82c74a935</p>

<p>spec:</p>

<p>nodeName: cluster2-controlplane1 # add the controlplane node name</p>

<p>containers:</p>

<p>- image: httpd:2.4-alpine</p>

<p>  imagePullPolicy: IfNotPresent</p>

<p>  name: manual-schedule</p>

<p>  resources: {}</p>

<p>  terminationMessagePath: /dev/termination-log</p>

<p>  terminationMessagePolicy: File</p>

<p>  volumeMounts:</p>

<p>  - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</p>

<p>    name: default-token-nxnc7</p>

<p>    readOnly: true</p>

<p>dnsPolicy: ClusterFirst</p>

<p>...</p>

<p>The only thing a scheduler does, is that it sets the nodeName for a <em>Pod</em> declaration. How it finds the correct node to schedule on, that's a very much complicated matter and takes many variables into account.</p>

<p>As we cannot kubectl apply or kubectl edit , in this case we need to delete and create or replace:</p>

<p>k -f 9.yaml replace --force</p>

<p>How does it look?</p>

<p>➜ k get pod manual-schedule -o wide</p>

<p>NAME             READY   STATUS   ...   NODE            </p>

<p>manual-schedule   1/1     Running   ...   cluster2-controlplane1</p>

<p>It looks like our <em>Pod</em> is running on the controlplane now as requested, although no tolerations were specified. Only the scheduler takes tains/tolerations/affinity into account when finding the correct node name. That's why it's still possible to assign <em>Pods</em> manually directly to a controlplane node and skip the scheduler.</p>

<p> </p>

<p><strong>Start the scheduler again</strong></p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>➜ root@cluster2-controlplane1:~# mv ../kube-scheduler.yaml .</p>

<p>Checks it's running:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep schedule</p>

<p>kube-scheduler-cluster2-controlplane1           1/1     Running   0         16s</p>

<p>Schedule a second test <em>Pod</em>:</p>

<p>k run manual-schedule2 --image=httpd:2.4-alpine</p>

<p>➜ k get pod -o wide | grep schedule</p>

<p>manual-schedule   1/1     Running   ...   cluster2-controlplane1</p>

<p>manual-schedule2   1/1     Running   ...   cluster2-node1</p>

<p>Back to normal.</p>

<p> </p>

<p> </p>

<p><strong>Question 10 | RBAC ServiceAccount Role RoleBinding</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a new <em>ServiceAccount</em> processor in <em>Namespace</em> project-hamster. Create a <em>Role</em> and <em>RoleBinding</em>, both named processor as well. These should allow the new <em>SA</em> to only create <em>Secrets</em> and <em>ConfigMaps</em> in that <em>Namespace</em>.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Let's talk a little about RBAC resources</strong></p>

<p>A <em>ClusterRole</em>|<em>Role</em> defines a set of permissions and <strong>where it is available</strong>, in the whole cluster or just a single <em>Namespace</em>.</p>

<p>A <em>ClusterRoleBinding</em>|<em>RoleBinding</em> connects a set of permissions with an account and defines <strong>where it is applied</strong>, in the whole cluster or just a single <em>Namespace</em>.</p>

<p>Because of this there are 4 different RBAC combinations and 3 valid ones:</p>

<ol>
  <li>
    <p><em>Role</em> + <em>RoleBinding</em> (available in single <em>Namespace</em>, applied in single <em>Namespace</em>)</p>
  </li>
  <li>
    <p><em>ClusterRole</em> + <em>ClusterRoleBinding</em> (available cluster-wide, applied cluster-wide)</p>
  </li>
  <li>
    <p><em>ClusterRole</em> + <em>RoleBinding</em> (available cluster-wide, applied in single <em>Namespace</em>)</p>
  </li>
  <li>
    <p><em>Role</em> + <em>ClusterRoleBinding</em> (<strong>NOT POSSIBLE:</strong> available in single <em>Namespace</em>, applied cluster-wide)</p>
  </li>
</ol>

<p><strong>To the solution</strong></p>

<p>We first create the <em>ServiceAccount</em>:</p>

<p>➜ k -n project-hamster create sa processor</p>

<p>serviceaccount/processor created</p>

<p>Then for the <em>Role</em>:</p>

<p>k -n project-hamster create role -h # examples</p>

<p>So we execute:</p>

<p>k -n project-hamster create role processor \</p>

<p>--verb=create \</p>

<p>--resource=secret \</p>

<p>--resource=configmap</p>

<p>Which will create a <em>Role</em> like:</p>

<p># kubectl -n project-hamster create role processor --verb=create --resource=secret --resource=configmap</p>

<p>apiVersion: rbac.authorization.k8s.io/v1</p>

<p>kind: Role</p>

<p>metadata:</p>

<p>name: processor</p>

<p>namespace: project-hamster</p>

<p>rules:</p>

<p>- apiGroups:</p>

<p>- ""</p>

<p>resources:</p>

<p>- secrets</p>

<p>- configmaps</p>

<p>verbs:</p>

<p>- create</p>

<p>Now we bind the <em>Role</em> to the <em>ServiceAccount</em>:</p>

<p>k -n project-hamster create rolebinding -h # examples</p>

<p>So we create it:</p>

<p>k -n project-hamster create rolebinding processor \</p>

<p>--role processor \</p>

<p>--serviceaccount project-hamster:processor</p>

<p>This will create a <em>RoleBinding</em> like:</p>

<p># kubectl -n project-hamster create rolebinding processor --role processor --serviceaccount project-hamster:processor</p>

<p>apiVersion: rbac.authorization.k8s.io/v1</p>

<p>kind: RoleBinding</p>

<p>metadata:</p>

<p>name: processor</p>

<p>namespace: project-hamster</p>

<p>roleRef:</p>

<p>apiGroup: rbac.authorization.k8s.io</p>

<p>kind: Role</p>

<p>name: processor</p>

<p>subjects:</p>

<p>- kind: ServiceAccount</p>

<p>name: processor</p>

<p>namespace: project-hamster</p>

<p>To test our RBAC setup we can use kubectl auth can-i:</p>

<p>k auth can-i -h # examples</p>

<p>Like this:</p>

<p>➜ k -n project-hamster auth can-i create secret \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>yes</p>

<p>➜ k -n project-hamster auth can-i create configmap \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>yes</p>

<p>➜ k -n project-hamster auth can-i create pod \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>no</p>

<p>➜ k -n project-hamster auth can-i delete secret \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>no</p>

<p>➜ k -n project-hamster auth can-i get configmap \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>no</p>

<p>Done.</p>

<p> </p>

<p> </p>

<p><strong>Question 11 | DaemonSet on all Nodes</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Use <em>Namespace</em> project-tiger for the following. Create a <em>DaemonSet</em> named ds-important with image httpd:2.4-alpine and labels id=ds-important and uuid=18426a0b-5f59-4e10-923f-c0e078e82462. The <em>Pods</em> it creates should request 10 millicore cpu and 10 mebibyte memory. The <em>Pods</em> of that <em>DaemonSet</em> should run on all nodes, also controlplanes.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>As of now we aren't able to create a <em>DaemonSet</em> directly using kubectl, so we create a <em>Deployment</em> and just change it up:</p>

<p>k -n project-tiger create deployment --image=httpd:2.4-alpine ds-important $do &gt; 11.yaml</p>

<p>vim 11.yaml</p>

<p>(Sure you could also search for a <em>DaemonSet</em> example yaml in the Kubernetes docs and alter it.)</p>

<p> </p>

<p>Then we adjust the yaml to:</p>

<p># 11.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: DaemonSet # change from Deployment to Daemonset</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:                                           # add</p>

<p>  id: ds-important                                # add</p>

<p>  uuid: 18426a0b-5f59-4e10-923f-c0e078e82462 # add</p>

<p>name: ds-important</p>

<p>namespace: project-tiger # important</p>

<p>spec:</p>

<p> #replicas: 1 # remove</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    id: ds-important # add</p>

<p>    uuid: 18426a0b-5f59-4e10-923f-c0e078e82462 # add</p>

<p> #strategy: {} # remove</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      id: ds-important # add</p>

<p>      uuid: 18426a0b-5f59-4e10-923f-c0e078e82462 # add</p>

<p>  spec:</p>

<p>    containers:</p>

<p>    - image: httpd:2.4-alpine</p>

<p>      name: ds-important</p>

<p>      resources:</p>

<p>        requests: # add</p>

<p>          cpu: 10m  # add</p>

<p>          memory: 10Mi  # add</p>

<p>    tolerations:                           # add</p>

<p>    - effect: NoSchedule                   # add</p>

<p>      key: node-role.kubernetes.io/control-plane  # add</p>

<p>#status: {} # remove</p>

<p>It was requested that the <em>DaemonSet</em> runs on all nodes, so we need to specify the toleration for this.</p>

<p>Let's confirm:</p>

<p>k -f 11.yaml create</p>

<p>➜ k -n project-tiger get ds</p>

<p>NAME           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</p>

<p>ds-important   3         3         3       3           3           &lt;none&gt;         8s</p>

<p>➜ k -n project-tiger get pod -l id=ds-important -o wide</p>

<p>NAME READY STATUS NODE</p>

<p>ds-important-6pvgm       1/1     Running   ...   cluster1-node1</p>

<p>ds-important-lh5ts       1/1     Running   ...   cluster1-controlplane1</p>

<p>ds-important-qhjcq       1/1     Running   ...   cluster1-node2</p>

<p> </p>

<p> </p>

<p><strong>Question 12 | Deployment on all Nodes</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Use <em>Namespace</em> project-tiger for the following. Create a <em>Deployment</em> named deploy-important with label id=very-important (the Pods should also have this label) and 3 replicas. It should contain two containers, the first named container1 with image nginx:1.17.6-alpine and the second one named container2 with image google/pause.</p>

<p>There should be only ever <strong>one</strong> <em>Pod</em> of that <em>Deployment</em> running on <strong>one</strong> worker node. We have two worker nodes: cluster1-node1 and cluster1-node2. Because the <em>Deployment</em> has three replicas the result should be that on both nodes <strong>one</strong> <em>Pod</em> is running. The third <em>Pod</em> won't be scheduled, unless a new worker node will be added.</p>

<p>In a way we kind of simulate the behaviour of a <em>DaemonSet</em> here, but using a <em>Deployment</em> and a fixed number of replicas.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>There are two possible ways, one using podAntiAffinity and one using topologySpreadConstraint.</p>

<p> </p>

<p><strong>PodAntiAffinity</strong></p>

<p>The idea here is that we create a "Inter-pod anti-affinity" which allows us to say a <em>Pod</em> should only be scheduled on a node where another <em>Pod</em> of a specific label (here the same label) is not already running.</p>

<p>Let's begin by creating the <em>Deployment</em> template:</p>

<p>k -n project-tiger create deployment \</p>

<p>--image=nginx:1.17.6-alpine deploy-important $do &gt; 12.yaml</p>

<p>vim 12.yaml</p>

<p>Then change the yaml to:</p>

<p># 12.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: Deployment</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  id: very-important # change</p>

<p>name: deploy-important</p>

<p>namespace: project-tiger # important</p>

<p>spec:</p>

<p>replicas: 3 # change</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    id: very-important # change</p>

<p>strategy: {}</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      id: very-important # change</p>

<p>  spec:</p>

<p>    containers:</p>

<p>    - image: nginx:1.17.6-alpine</p>

<p>      name: container1 # change</p>

<p>      resources: {}</p>

<p>    - image: google/pause             # add</p>

<p>      name: container2 # add</p>

<p>    affinity:  # add</p>

<p>      podAntiAffinity:  # add</p>

<p>        requiredDuringSchedulingIgnoredDuringExecution: # add</p>

<p>        - labelSelector: # add</p>

<p>            matchExpressions: # add</p>

<p>            - key: id # add</p>

<p>              operator: In  # add</p>

<p>              values:  # add</p>

<p>              - very-important  # add</p>

<p>          topologyKey: kubernetes.io/hostname  # add</p>

<p>status: {}</p>

<p>Specify a topologyKey, which is a pre-populated Kubernetes label, you can find this by describing a node.</p>

<p> </p>

<p><strong>TopologySpreadConstraints</strong></p>

<p>We can achieve the same with topologySpreadConstraints. Best to try out and play with both.</p>

<p># 12.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: Deployment</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  id: very-important # change</p>

<p>name: deploy-important</p>

<p>namespace: project-tiger # important</p>

<p>spec:</p>

<p>replicas: 3 # change</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    id: very-important # change</p>

<p>strategy: {}</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      id: very-important # change</p>

<p>  spec:</p>

<p>    containers:</p>

<p>    - image: nginx:1.17.6-alpine</p>

<p>      name: container1 # change</p>

<p>      resources: {}</p>

<p>    - image: google/pause             # add</p>

<p>      name: container2 # add</p>

<p>    topologySpreadConstraints:                 # add</p>

<p>    - maxSkew: 1                               # add</p>

<p>      topologyKey: kubernetes.io/hostname      # add</p>

<p>      whenUnsatisfiable: DoNotSchedule         # add</p>

<p>      labelSelector:                           # add</p>

<p>        matchLabels:                           # add</p>

<p>          id: very-important                   # add</p>

<p>status: {}</p>

<p> </p>

<p><strong>Apply and Run</strong></p>

<p>Let's run it:</p>

<p>k -f 12.yaml create</p>

<p>Then we check the <em>Deployment</em> status where it shows 2/3 ready count:</p>

<p>➜ k -n project-tiger get deploy -l id=very-important</p>

<p>NAME               READY   UP-TO-DATE   AVAILABLE   AGE</p>

<p>deploy-important   2/3     3           2           2m35s</p>

<p>And running the following we see one <em>Pod</em> on each worker node and one not scheduled.</p>

<p>➜ k -n project-tiger get pod -o wide -l id=very-important</p>

<p>NAME                               READY   STATUS   ...   NODE            </p>

<p>deploy-important-58db9db6fc-9ljpw   2/2     Running   ...   cluster1-node1</p>

<p>deploy-important-58db9db6fc-lnxdb   0/2     Pending   ...   &lt;none&gt;          </p>

<p>deploy-important-58db9db6fc-p2rz8   2/2     Running   ...   cluster1-node2</p>

<p>If we kubectl describe the <em>Pod</em> deploy-important-58db9db6fc-lnxdb it will show us the reason for not scheduling is our implemented podAntiAffinity ruling:</p>

<p>Warning FailedScheduling 63s (x3 over 65s) default-scheduler 0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/control-plane: }, that the pod didn't tolerate, 2 node(s) didn't match pod affinity/anti-affinity, 2 node(s) didn't satisfy existing pods anti-affinity rules.</p>

<p>Or our topologySpreadConstraints:</p>

<p>Warning FailedScheduling 16s   default-scheduler 0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/control-plane: }, that the pod didn't tolerate, 2 node(s) didn't match pod topology spread constraints.</p>

<p> </p>

<p> </p>

<p><strong>Question 13 | Multi Containers and Pod shared Volume</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a <em>Pod</em> named multi-container-playground in <em>Namespace</em> default with three containers, named c1, c2 and c3. There should be a volume attached to that <em>Pod</em> and mounted into every container, but the volume shouldn't be persisted or shared with other <em>Pods</em>.</p>

<p>Container c1 should be of image nginx:1.17.6-alpine and have the name of the node where its <em>Pod</em> is running available as environment variable MY_NODE_NAME.</p>

<p>Container c2 should be of image busybox:1.31.1 and write the output of the date command every second in the shared volume into file date.log. You can use while true; do date &gt;&gt; /your/vol/path/date.log; sleep 1; done for this.</p>

<p>Container c3 should be of image busybox:1.31.1 and constantly send the content of file date.log from the shared volume to stdout. You can use tail -f /your/vol/path/date.log for this.</p>

<p>Check the logs of container c3 to confirm correct setup.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we create the <em>Pod</em> template:</p>

<p>k run multi-container-playground --image=nginx:1.17.6-alpine $do &gt; 13.yaml</p>

<p>vim 13.yaml</p>

<p>And add the other containers and the commands they should execute:</p>

<p># 13.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: multi-container-playground</p>

<p>name: multi-container-playground</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.17.6-alpine</p>

<p>  name: c1                                                                      # change</p>

<p>  resources: {}</p>

<p>  env:                                                                          # add</p>

<p>  - name: MY_NODE_NAME                                                          # add</p>

<p>    valueFrom:                                                                  # add</p>

<p>      fieldRef:                                                                 # add</p>

<p>        fieldPath: spec.nodeName                                                # add</p>

<p>  volumeMounts:                                                                 # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    mountPath: /vol                                                             # add</p>

<p>- image: busybox:1.31.1                                                         # add</p>

<p>  name: c2                                                                      # add</p>

<p>  command: ["sh", "-c", "while true; do date &gt;&gt; /vol/date.log; sleep 1; done"]  # add</p>

<p>  volumeMounts:                                                                 # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    mountPath: /vol                                                             # add</p>

<p>- image: busybox:1.31.1                                                         # add</p>

<p>  name: c3                                                                      # add</p>

<p>  command: ["sh", "-c", "tail -f /vol/date.log"]                                # add</p>

<p>  volumeMounts:                                                                 # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    mountPath: /vol                                                             # add</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>volumes:                                                                        # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    emptyDir: {}                                                                # add</p>

<p>status: {}</p>

<p>k -f 13.yaml create</p>

<p>Oh boy, lot's of requested things. We check if everything is good with the <em>Pod</em>:</p>

<p>➜ k get pod multi-container-playground</p>

<p>NAME                         READY   STATUS   RESTARTS   AGE</p>

<p>multi-container-playground   3/3     Running   0         95s</p>

<p>Good, then we check if container c1 has the requested node name as env variable:</p>

<p>➜ k exec multi-container-playground -c c1 -- env | grep MY</p>

<p>MY_NODE_NAME=cluster1-node2</p>

<p>And finally we check the logging:</p>

<p>➜ k logs multi-container-playground -c c3</p>

<p>Sat Dec 7 16:05:10 UTC 2077</p>

<p>Sat Dec 7 16:05:11 UTC 2077</p>

<p>Sat Dec 7 16:05:12 UTC 2077</p>

<p>Sat Dec 7 16:05:13 UTC 2077</p>

<p>Sat Dec 7 16:05:14 UTC 2077</p>

<p>Sat Dec 7 16:05:15 UTC 2077</p>

<p>Sat Dec 7 16:05:16 UTC 2077</p>

<p> </p>

<p> </p>

<p><strong>Question 14 | Find out Cluster Information</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>You're ask to find out following information about the cluster k8s-c1-H:</p>

<ol>
  <li>
    <p>How many controlplane nodes are available?</p>
  </li>
  <li>
    <p>How many worker nodes are available?</p>
  </li>
  <li>
    <p>What is the Service CIDR?</p>
  </li>
  <li>
    <p>Which Networking (or CNI Plugin) is configured and where is its config file?</p>
  </li>
  <li>
    <p>Which suffix will static pods have that run on cluster1-node1?</p>
  </li>
</ol>

<p>Write your answers into file /opt/course/14/cluster-info, structured like this:</p>

<p># /opt/course/14/cluster-info</p>

<p>1: [ANSWER]</p>

<p>2: [ANSWER]</p>

<p>3: [ANSWER]</p>

<p>4: [ANSWER]</p>

<p>5: [ANSWER]</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>How many controlplane and worker nodes are available?</strong></p>

<p>➜ k get node</p>

<p>NAME                   STATUS   ROLES         AGE   VERSION</p>

<p>cluster1-controlplane1 Ready   control-plane 27h   v1.28.2</p>

<p>cluster1-node1         Ready   &lt;none&gt;         27h   v1.28.2</p>

<p>cluster1-node2         Ready   &lt;none&gt;         27h   v1.28.2</p>

<p>We see one controlplane and two workers.</p>

<p> </p>

<p><strong>What is the Service CIDR?</strong></p>

<p>➜ ssh cluster1-controlplane1</p>

<p>➜ root@cluster1-controlplane1:~# cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep range</p>

<p>  - --service-cluster-ip-range=10.96.0.0/12</p>

<p> </p>

<p><strong>Which Networking (or CNI Plugin) is configured and where is its config file?</strong></p>

<p>➜ root@cluster1-controlplane1:~# find /etc/cni/net.d/</p>

<p>/etc/cni/net.d/</p>

<p>/etc/cni/net.d/10-weave.conflist</p>

<p>➜ root@cluster1-controlplane1:~# cat /etc/cni/net.d/10-weave.conflist</p>

<p>{</p>

<p>  "cniVersion": "0.3.0",</p>

<p>  "name": "weave",</p>

<p>...</p>

<p>By default the kubelet looks into /etc/cni/net.d to discover the CNI plugins. This will be the same on every controlplane and worker nodes.</p>

<p> </p>

<p><strong>Which suffix will static pods have that run on cluster1-node1?</strong></p>

<p>The suffix is the node hostname with a leading hyphen. It used to be -static in earlier Kubernetes versions.</p>

<p> </p>

<p><strong>Result</strong></p>

<p>The resulting /opt/course/14/cluster-info could look like:</p>

<p># /opt/course/14/cluster-info</p>

<p># How many controlplane nodes are available?</p>

<p>1: 1</p>

<p># How many worker nodes are available?</p>

<p>2: 2</p>

<p># What is the Service CIDR?</p>

<p>3: 10.96.0.0/12</p>

<p># Which Networking (or CNI Plugin) is configured and where is its config file?</p>

<p>4: Weave, /etc/cni/net.d/10-weave.conflist</p>

<p># Which suffix will static pods have that run on cluster1-node1?</p>

<p>5: -cluster1-node1</p>

<p> </p>

<p> </p>

<p><strong>Question 15 | Cluster Event Logging</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Write a command into /opt/course/15/cluster_events.sh which shows the latest events in the whole cluster, ordered by time (metadata.creationTimestamp). Use kubectl for it.</p>

<p>Now delete the kube-proxy <em>Pod</em> running on node cluster2-node1 and write the events this caused into /opt/course/15/pod_kill.log.</p>

<p>Finally kill the containerd container of the kube-proxy <em>Pod</em> on node cluster2-node1 and write the events into /opt/course/15/container_kill.log.</p>

<p>Do you notice differences in the events both actions caused?</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p># /opt/course/15/cluster_events.sh</p>

<p>kubectl get events -A --sort-by=.metadata.creationTimestamp</p>

<p>Now we delete the kube-proxy <em>Pod</em>:</p>

<p>k -n kube-system get pod -o wide | grep proxy # find pod running on cluster2-node1</p>

<p>k -n kube-system delete pod kube-proxy-z64cg</p>

<p>Now check the events:</p>

<p>sh /opt/course/15/cluster_events.sh</p>

<p>Write the events the killing caused into /opt/course/15/pod_kill.log:</p>

<p># /opt/course/15/pod_kill.log</p>

<p>kube-system   9s         Normal   Killing           pod/kube-proxy-jsv7t   ...</p>

<p>kube-system   3s         Normal   SuccessfulCreate daemonset/kube-proxy   ...</p>

<p>kube-system   &lt;unknown&gt;   Normal   Scheduled         pod/kube-proxy-m52sx   ...</p>

<p>default       2s         Normal   Starting         node/cluster2-node1 ...</p>

<p>kube-system   2s         Normal   Created           pod/kube-proxy-m52sx   ...</p>

<p>kube-system   2s         Normal   Pulled           pod/kube-proxy-m52sx   ...</p>

<p>kube-system   2s         Normal   Started           pod/kube-proxy-m52sx   ...</p>

<p>Finally we will try to provoke events by killing the container belonging to the container of the kube-proxy <em>Pod</em>:</p>

<p>➜ ssh cluster2-node1</p>

<p>➜ root@cluster2-node1:~# crictl ps | grep kube-proxy</p>

<p>1e020b43c4423   36c4ebbc9d979   About an hour ago   Running   kube-proxy     ...</p>

<p>➜ root@cluster2-node1:~# crictl rm 1e020b43c4423</p>

<p>1e020b43c4423</p>

<p>➜ root@cluster2-node1:~# crictl ps | grep kube-proxy</p>

<p>0ae4245707910   36c4ebbc9d979   17 seconds ago     Running   kube-proxy     ...    </p>

<p>We killed the main container (1e020b43c4423), but also noticed that a new container (0ae4245707910) was directly created. Thanks Kubernetes!</p>

<p>Now we see if this caused events again and we write those into the second file:</p>

<p>sh /opt/course/15/cluster_events.sh</p>

<p># /opt/course/15/container_kill.log</p>

<p>kube-system   13s         Normal   Created     pod/kube-proxy-m52sx   ...</p>

<p>kube-system   13s         Normal   Pulled       pod/kube-proxy-m52sx   ...</p>

<p>kube-system   13s         Normal   Started     pod/kube-proxy-m52sx   ...</p>

<p>Comparing the events we see that when we deleted the whole <em>Pod</em> there were more things to be done, hence more events. For example was the <em>DaemonSet</em> in the game to re-create the missing <em>Pod</em>. Where when we manually killed the main container of the <em>Pod</em>, the <em>Pod</em> would still exist but only its container needed to be re-created, hence less events.</p>

<p> </p>

<p> </p>

<p><strong>Question 16 | Namespaces and Api Resources</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Write the names of all namespaced Kubernetes resources (like <em>Pod</em>, <em>Secret</em>, <em>ConfigMap</em>...) into /opt/course/16/resources.txt.</p>

<p>Find the project-* <em>Namespace</em> with the highest number of Roles defined in it and write its name and amount of <em>Roles</em> into /opt/course/16/crowded-namespace.txt.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Namespace and Namespaces Resources</strong></p>

<p>Now we can get a list of all resources like:</p>

<p>k api-resources    # shows all</p>

<p>k api-resources -h # help always good</p>

<p>k api-resources --namespaced -o name &gt; /opt/course/16/resources.txt</p>

<p>Which results in the file:</p>

<p># /opt/course/16/resources.txt</p>

<p>bindings</p>

<p>configmaps</p>

<p>endpoints</p>

<p>events</p>

<p>limitranges</p>

<p>persistentvolumeclaims</p>

<p>pods</p>

<p>podtemplates</p>

<p>replicationcontrollers</p>

<p>resourcequotas</p>

<p>secrets</p>

<p>serviceaccounts</p>

<p>services</p>

<p>controllerrevisions.apps</p>

<p>daemonsets.apps</p>

<p>deployments.apps</p>

<p>replicasets.apps</p>

<p>statefulsets.apps</p>

<p>localsubjectaccessreviews.authorization.k8s.io</p>

<p>horizontalpodautoscalers.autoscaling</p>

<p>cronjobs.batch</p>

<p>jobs.batch</p>

<p>leases.coordination.k8s.io</p>

<p>events.events.k8s.io</p>

<p>ingresses.extensions</p>

<p>ingresses.networking.k8s.io</p>

<p>networkpolicies.networking.k8s.io</p>

<p>poddisruptionbudgets.policy</p>

<p>rolebindings.rbac.authorization.k8s.io</p>

<p>roles.rbac.authorization.k8s.io</p>

<p> </p>

<p><strong>Namespace with most Roles</strong></p>

<p>➜ k -n project-c13 get role --no-headers | wc -l</p>

<p>No resources found in project-c13 namespace.</p>

<p>0</p>

<p>➜ k -n project-c14 get role --no-headers | wc -l</p>

<p>300</p>

<p>➜ k -n project-hamster get role --no-headers | wc -l</p>

<p>No resources found in project-hamster namespace.</p>

<p>0</p>

<p>➜ k -n project-snake get role --no-headers | wc -l</p>

<p>No resources found in project-snake namespace.</p>

<p>0</p>

<p>➜ k -n project-tiger get role --no-headers | wc -l</p>

<p>No resources found in project-tiger namespace.</p>

<p>0</p>

<p>Finally we write the name and amount into the file:</p>

<p># /opt/course/16/crowded-namespace.txt</p>

<p>project-c14 with 300 resources</p>

<p> </p>

<p> </p>

<p><strong>Question 17 | Find Container of Pod and check info</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>In <em>Namespace</em> project-tiger create a <em>Pod</em> named tigers-reunite of image httpd:2.4.41-alpine with labels pod=container and container=pod. Find out on which node the <em>Pod</em> is scheduled. Ssh into that node and find the containerd container belonging to that <em>Pod</em>.</p>

<p>Using command crictl:</p>

<ol>
  <li>
    <p>Write the ID of the container and the info.runtimeType into /opt/course/17/pod-container.txt</p>
  </li>
  <li>
    <p>Write the logs of the container into /opt/course/17/pod-container.log</p>
  </li>
</ol>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we create the <em>Pod</em>:</p>

<p>k -n project-tiger run tigers-reunite \</p>

<p>--image=httpd:2.4.41-alpine \</p>

<p>--labels "pod=container,container=pod"</p>

<p>Next we find out the node it's scheduled on:</p>

<p>k -n project-tiger get pod -o wide</p>

<p># or fancy:</p>

<p>k -n project-tiger get pod tigers-reunite -o jsonpath="{.spec.nodeName}"</p>

<p>Then we ssh into that node and and check the container info:</p>

<p>➜ ssh cluster1-node2</p>

<p>➜ root@cluster1-node2:~# crictl ps | grep tigers-reunite</p>

<p>b01edbe6f89ed   54b0995a63052   5 seconds ago   Running       tigers-reunite ...</p>

<p>➜ root@cluster1-node2:~# crictl inspect b01edbe6f89ed | grep runtimeType</p>

<p>  "runtimeType": "io.containerd.runc.v2",</p>

<p>Then we fill the requested file (on the main terminal):</p>

<p># /opt/course/17/pod-container.txt</p>

<p>b01edbe6f89ed io.containerd.runc.v2</p>

<p>Finally we write the container logs in the second file:</p>

<p>ssh cluster1-node2 'crictl logs b01edbe6f89ed' &amp;&gt; /opt/course/17/pod-container.log</p>

<p>The &amp;&gt; in above's command redirects both the standard output and standard error.</p>

<p>You could also simply run crictl logs on the node and copy the content manually, if it's not a lot. The file should look like:</p>

<p># /opt/course/17/pod-container.log</p>

<p>AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.44.0.37. Set the 'ServerName' directive globally to suppress this message</p>

<p>AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.44.0.37. Set the 'ServerName' directive globally to suppress this message</p>

<p>[Mon Sep 13 13:32:18.555280 2021] [mpm_event:notice] [pid 1:tid 139929534545224] AH00489: Apache/2.4.41 (Unix) configured -- resuming normal operations</p>

<p>[Mon Sep 13 13:32:18.555610 2021] [core:notice] [pid 1:tid 139929534545224] AH00094: Command line: 'httpd -D FOREGROUND'</p>

<p> </p>

<p> </p>

<p><strong>Question 18 | Fix Kubelet</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>There seems to be an issue with the kubelet not running on cluster3-node1. Fix it and confirm that cluster has node cluster3-node1 available in Ready state afterwards. You should be able to schedule a <em>Pod</em> on cluster3-node1 afterwards.</p>

<p>Write the reason of the issue into /opt/course/18/reason.txt.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>The procedure on tasks like these should be to check if the kubelet is running, if not start it, then check its logs and correct errors if there are some.</p>

<p>Always helpful to check if other clusters already have some of the components defined and running, so you can copy and use existing config files. Though in this case it might not need to be necessary.</p>

<p>Check node status:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS     ROLES           AGE   VERSION</p>

<p>cluster3-controlplane1   Ready     control-plane   14d   v1.28.2</p>

<p>cluster3-node1           NotReady   &lt;none&gt;         14d   v1.28.2</p>

<p>First we check if the kubelet is running:</p>

<p>➜ ssh cluster3-node1</p>

<p>➜ root@cluster3-node1:~# ps aux | grep kubelet</p>

<p>root     29294 0.0 0.2 14856 1016 pts/0   S+   11:30   0:00 grep --color=auto kubelet</p>

<p>Nope, so we check if it's configured using systemd as service:</p>

<p>➜ root@cluster3-node1:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>  Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>Drop-In: /etc/systemd/system/kubelet.service.d</p>

<p>          └─10-kubeadm.conf</p>

<p>  Active: inactive (dead) since Sun 2019-12-08 11:30:06 UTC; 50min 52s ago</p>

<p>...</p>

<p>Yes, it's configured as a service with config at /etc/systemd/system/kubelet.service.d/10-kubeadm.conf, but we see it's inactive. Let's try to start it:</p>

<p>➜ root@cluster3-node1:~# service kubelet start</p>

<p>➜ root@cluster3-node1:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>  Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>Drop-In: /etc/systemd/system/kubelet.service.d</p>

<p>          └─10-kubeadm.conf</p>

<p>  Active: activating (auto-restart) (Result: exit-code) since Thu 2020-04-30 22:03:10 UTC; 3s ago</p>

<p>    Docs: https://kubernetes.io/docs/home/</p>

<p>Process: 5989 ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=203/EXEC)</p>

<p>Main PID: 5989 (code=exited, status=203/EXEC)</p>

<p>Apr 30 22:03:10 cluster3-node1 systemd[5989]: kubelet.service: Failed at step EXEC spawning /usr/local/bin/kubelet: No such file or directory</p>

<p>Apr 30 22:03:10 cluster3-node1 systemd[1]: kubelet.service: Main process exited, code=exited, status=203/EXEC</p>

<p>Apr 30 22:03:10 cluster3-node1 systemd[1]: kubelet.service: Failed with result 'exit-code'.</p>

<p>We see it's trying to execute /usr/local/bin/kubelet with some parameters defined in its service config file. A good way to find errors and get more logs is to run the command manually (usually also with its parameters).</p>

<p>➜ root@cluster3-node1:~# /usr/local/bin/kubelet</p>

<p>-bash: /usr/local/bin/kubelet: No such file or directory</p>

<p>➜ root@cluster3-node1:~# whereis kubelet</p>

<p>kubelet: /usr/bin/kubelet</p>

<p>Another way would be to see the extended logging of a service like using journalctl -u kubelet.</p>

<p><strong>Well, there we have it, wrong path specified. Correct the path in file</strong> /etc/systemd/system/kubelet.service.d/10-kubeadm.conf and run:</p>

<p>vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf # fix</p>

<p>systemctl daemon-reload &amp;&amp; systemctl restart kubelet</p>

<p>systemctl status kubelet  # should now show running</p>

<p>Also the node should be available for the api server, <strong>give it a bit of time though</strong>:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster3-controlplane1   Ready   control-plane   14d   v1.28.2</p>

<p>cluster3-node1           Ready   &lt;none&gt;         14d   v1.28.2</p>

<p>Finally we write the reason into the file:</p>

<p># /opt/course/18/reason.txt</p>

<p>wrong path to kubelet binary specified in service config</p>

<p> </p>

<p> </p>

<p><strong>Question 19 | Create Secret and mount into Pod</strong></p>

<p> </p>

<p><strong>NOTE:</strong> This task can only be solved if questions 18 or 20 have been successfully implemented and the k8s-c3-CCC cluster has a functioning worker node</p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Do the following in a new <em>Namespace</em> secret. Create a <em>Pod</em> named secret-pod of image busybox:1.31.1 which should keep running for some time.</p>

<p>There is an existing <em>Secret</em> located at /opt/course/19/secret1.yaml, create it in the <em>Namespace</em> secret and mount it readonly into the <em>Pod</em> at /tmp/secret1.</p>

<p>Create a new <em>Secret</em> in <em>Namespace</em> secret called secret2 which should contain user=user1 and pass=1234. These entries should be available inside the <em>Pod's</em> container as environment variables APP_USER and APP_PASS.</p>

<p>Confirm everything is working.</p>

<p> </p>

<p><strong>Answer</strong></p>

<p>First we create the <em>Namespace</em> and the requested <em>Secrets</em> in it:</p>

<p>k create ns secret</p>

<p>cp /opt/course/19/secret1.yaml 19_secret1.yaml</p>

<p>vim 19_secret1.yaml</p>

<p>We need to adjust the <em>Namespace</em> for that <em>Secret</em>:</p>

<p># 19_secret1.yaml</p>

<p>apiVersion: v1</p>

<p>data:</p>

<p>halt: IyEgL2Jpbi9zaAo...</p>

<p>kind: Secret</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>name: secret1</p>

<p>namespace: secret # change</p>

<p>k -f 19_secret1.yaml create</p>

<p>Next we create the second <em>Secret</em>:</p>

<p>k -n secret create secret generic secret2 --from-literal=user=user1 --from-literal=pass=1234</p>

<p>Now we create the <em>Pod</em> template:</p>

<p>k -n secret run secret-pod --image=busybox:1.31.1 $do -- sh -c "sleep 5d" &gt; 19.yaml</p>

<p>vim 19.yaml</p>

<p>Then make the necessary changes:</p>

<p># 19.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: secret-pod</p>

<p>name: secret-pod</p>

<p>namespace: secret            # add</p>

<p>spec:</p>

<p>containers:</p>

<p>- args:</p>

<p>  - sh</p>

<p>  - -c</p>

<p>  - sleep 1d</p>

<p>  image: busybox:1.31.1</p>

<p>  name: secret-pod</p>

<p>  resources: {}</p>

<p>  env: # add</p>

<p>  - name: APP_USER # add</p>

<p>    valueFrom: # add</p>

<p>      secretKeyRef: # add</p>

<p>        name: secret2 # add</p>

<p>        key: user # add</p>

<p>  - name: APP_PASS # add</p>

<p>    valueFrom: # add</p>

<p>      secretKeyRef: # add</p>

<p>        name: secret2 # add</p>

<p>        key: pass # add</p>

<p>  volumeMounts:  # add</p>

<p>  - name: secret1 # add</p>

<p>    mountPath: /tmp/secret1 # add</p>

<p>    readOnly: true # add</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>volumes: # add</p>

<p>- name: secret1 # add</p>

<p>  secret: # add</p>

<p>    secretName: secret1 # add</p>

<p>status: {}</p>

<p>It might not be necessary in current K8s versions to specify the readOnly: true because it's the <a href="https://github.com/kubernetes/kubernetes/issues/62099">[default setting anyways]{.underline}</a>.</p>

<p>And execute:</p>

<p>k -f 19.yaml create</p>

<p>Finally we check if all is correct:</p>

<p>➜ k -n secret exec secret-pod -- env | grep APP</p>

<p>APP_PASS=1234</p>

<p>APP_USER=user1</p>

<p>➜ k -n secret exec secret-pod -- find /tmp/secret1</p>

<p>/tmp/secret1</p>

<p>/tmp/secret1/..data</p>

<p>/tmp/secret1/halt</p>

<p>/tmp/secret1/..2019_12_08_12_15_39.463036797</p>

<p>/tmp/secret1/..2019_12_08_12_15_39.463036797/halt</p>

<p>➜ k -n secret exec secret-pod -- cat /tmp/secret1/halt</p>

<p>#! /bin/sh</p>

<p>### BEGIN INIT INFO</p>

<p># Provides:         halt</p>

<p># Required-Start:</p>

<p># Required-Stop:</p>

<p># Default-Start:</p>

<p># Default-Stop:     0</p>

<p># Short-Description: Execute the halt command.</p>

<p># Description:</p>

<p>...</p>

<p>All is good.</p>

<p> </p>

<p> </p>

<p><strong>Question 20 | Update Kubernetes Version and join cluster</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Your coworker said node cluster3-node2 is running an older Kubernetes version and is not even part of the cluster. Update Kubernetes on that node to the exact version that's running on cluster3-controlplane1. Then add this node to the cluster. Use kubeadm for this.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Upgrade Kubernetes to cluster3-controlplane1 version</strong></p>

<p>Search in the docs for kubeadm upgrade: <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade">[https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade]{.underline}</a></p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster3-controlplane1   Ready   control-plane   22h   v1.28.2</p>

<p>cluster3-node1           Ready   &lt;none&gt;         22h   v1.28.2</p>

<p>Controlplane node seems to be running Kubernetes 1.28.2. Node cluster3-node2 might not yet be part of the cluster depending on previous tasks.</p>

<p>➜ ssh cluster3-node2</p>

<p>➜ root@cluster3-node2:~# kubeadm version</p>

<p>kubeadm version: &amp;version.Info{Major:"1", Minor:"27", GitVersion:"v1.27.4", GitCommit:"fa3d7990104d7c1f16943a67f11b154b71f6a132", GitTreeState:"clean", BuildDate:"2023-07-19T12:19:40Z", GoVersion:"go1.20.6", Compiler:"gc", Platform:"linux/amd64"}</p>

<p>➜ root@cluster3-node2:~# kubectl version --short</p>

<p>Flag --short has been deprecated, and will be removed in the future. The --short output will become the default.</p>

<p>Client Version: v1.27.4</p>

<p>Kustomize Version: v5.0.1</p>

<p>The connection to the server localhost:8080 was refused - did you specify the right host or port?</p>

<p>➜ root@cluster3-node2:~# kubelet --version</p>

<p>Kubernetes v1.27.4</p>

<p>Here kubeadm is already installed in the wanted version, so we don't need to install it. Hence we can run:</p>

<p>➜ root@cluster3-node2:~# kubeadm upgrade node</p>

<p>couldn't create a Kubernetes client from file "/etc/kubernetes/kubelet.conf": failed to load admin kubeconfig: open /etc/kubernetes/kubelet.conf: no such file or directory</p>

<p>To see the stack trace of this error execute with --v=5 or higher</p>

<p>This is usually the proper command to upgrade a node. But this error means that this node was never even initialised, so nothing to update here. This will be done later using kubeadm join. For now we can continue with kubelet and kubectl:</p>

<p>➜ root@cluster3-node2:~# apt update</p>

<p>Hit:1 http://ppa.launchpad.net/rmescandon/yq/ubuntu focal InRelease</p>

<p>Get:2 http://security.ubuntu.com/ubuntu focal-security InRelease [114 kB]                        </p>

<p>Hit:4 http://us.archive.ubuntu.com/ubuntu focal InRelease                                        </p>

<p>Get:3 https://packages.cloud.google.com/apt kubernetes-xenial InRelease [8,993 B]</p>

<p>Get:5 http://us.archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]</p>

<p>Get:6 http://us.archive.ubuntu.com/ubuntu focal-backports InRelease [108 kB]</p>

<p>Get:7 http://us.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [2,851 kB]</p>

<p>Get:8 http://us.archive.ubuntu.com/ubuntu focal-updates/main i386 Packages [884 kB]</p>

<p>Get:9 http://us.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [1,117 kB]</p>

<p>Get:10 http://us.archive.ubuntu.com/ubuntu focal-updates/universe i386 Packages [748 kB]</p>

<p>Fetched 5,946 kB in 3s (2,063 kB/s)                      </p>

<p>Reading package lists... Done</p>

<p>Building dependency tree      </p>

<p>Reading state information... Done</p>

<p>217 packages can be upgraded. Run 'apt list --upgradable' to see them.</p>

<p>➜ root@cluster3-node2:~# apt show kubectl -a | grep 1.28</p>

<p>...</p>

<p>Version: 1.28.2-00</p>

<p>Version: 1.28.1-00</p>

<p>Version: 1.28.0-00</p>

<p>➜ root@cluster3-node2:~# apt install kubectl=1.28.2-00 kubelet=1.28.2-00</p>

<p>...</p>

<p>Fetched 29.1 MB in 4s (7,547 kB/s)  </p>

<p>(Reading database ... 112527 files and directories currently installed.)</p>

<p>Preparing to unpack .../kubectl_1.28.2-00_amd64.deb ...</p>

<p>Unpacking kubectl (1.28.2-00) over (1.27.4-00) ...</p>

<p>dpkg: warning: downgrading kubelet from 1.27.4-00 to 1.28.2-00</p>

<p>Preparing to unpack .../kubelet_1.28.2-00_amd64.deb ...</p>

<p>Unpacking kubelet (1.28.2-00) over (1.27.4-00) ...</p>

<p>Setting up kubectl (1.28.2-00) ...</p>

<p>Setting up kubelet (1.28.2-00) ...</p>

<p>➜ root@cluster3-node2:~# kubelet --version</p>

<p>Kubernetes v1.28.2</p>

<p>Now we're up to date with kubeadm, kubectl and kubelet. Restart the kubelet:</p>

<p>➜ root@cluster3-node2:~# service kubelet restart</p>

<p>➜ root@cluster3-node2:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>    Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>  Drop-In: /etc/systemd/system/kubelet.service.d</p>

<p>            └─10-kubeadm.conf</p>

<p>    Active: activating (auto-restart) (Result: exit-code) since Fri 2023-09-22 14:37:37 UTC; 2s a&gt;</p>

<p>      Docs: https://kubernetes.io/docs/home/</p>

<p>  Process: 34331 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBEL&gt;</p>

<p>  Main PID: 34331 (code=exited, status=1/FAILURE)</p>

<p>Sep 22 14:37:37 cluster3-node2 systemd[1]: kubelet.service: Main process exited, code=exited, stat&gt;</p>

<p>Sep 22 14:37:37 cluster3-node2 systemd[1]: kubelet.service: Failed with result 'exit-code'.</p>

<p>These errors occur because we still need to run kubeadm join to join the node into the cluster. Let's do this in the next step.</p>

<p> </p>

<p><strong>Add cluster3-node2 to cluster</strong></p>

<p>First we log into the controlplane1 and generate a new TLS bootstrap token, also printing out the join command:</p>

<p>➜ ssh cluster3-controlplane1</p>

<p>➜ root@cluster3-controlplane1:~# kubeadm token create --print-join-command</p>

<p>kubeadm join 192.168.100.31:6443 --token lyl4o0.vbkmv9rdph5qd660 --discovery-token-ca-cert-hash sha256:b0c94ccf935e27306ff24bce4b8f611c621509e80075105b3f25d296a94927ce</p>

<p>➜ root@cluster3-controlplane1:~# kubeadm token list</p>

<p>TOKEN                     TTL         EXPIRES               ...</p>

<p>lyl4o0.vbkmv9rdph5qd660   23h         2023-09-23T14:38:12Z   ...</p>

<p>n4dkqj.hu52l46jfo4he61e   &lt;forever&gt;   &lt;never&gt;               ...</p>

<p>s7cmex.ty1olulkuljju9am   18h         2023-09-23T09:34:20Z   ...</p>

<p>We see the expiration of 23h for our token, we could adjust this by passing the ttl argument.</p>

<p>Next we connect again to cluster3-node2 and simply execute the join command:</p>

<p>➜ ssh cluster3-node2</p>

<p>➜ root@cluster3-node2:~# kubeadm join 192.168.100.31:6443 --token lyl4o0.vbkmv9rdph5qd660 --discovery-token-ca-cert-hash sha256:b0c94ccf935e27306ff24bce4b8f611c621509e80075105b3f25d296a94927ce</p>

<p>[preflight] Running pre-flight checks</p>

<p>[preflight] Reading configuration from the cluster...</p>

<p>[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'</p>

<p>W0922 14:39:56.786605   34648 configset.go:177] error unmarshaling configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"KubeProxyConfiguration"}: strict decoding error: unknown field "logging"</p>

<p>[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</p>

<p>[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</p>

<p>[kubelet-start] Starting the kubelet</p>

<p>[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</p>

<p>This node has joined the cluster:</p>

<p>* Certificate signing request was sent to apiserver and a response was received.</p>

<p>* The Kubelet was informed of the new secure connection details.</p>

<p>Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</p>

<p>➜ root@cluster3-node2:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>    Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>  Drop-In: /etc/systemd/system/kubelet.service.d</p>

<p>            └─10-kubeadm.conf</p>

<p>    Active: active (running) since Fri 2023-09-22 14:39:57 UTC; 14s ago</p>

<p>      Docs: https://kubernetes.io/docs/home/</p>

<p>  Main PID: 34695 (kubelet)</p>

<p>    Tasks: 12 (limit: 462)</p>

<p>    Memory: 55.4M</p>

<p>...</p>

<p>If you have troubles with kubeadm join you might need to run kubeadm reset.</p>

<p>This looks great though for us. Finally we head back to the main terminal and check the node status:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS     ROLES           AGE   VERSION</p>

<p>cluster3-controlplane1   Ready     control-plane   102m   v1.28.2</p>

<p>cluster3-node1           Ready     &lt;none&gt;         97m   v1.28.2</p>

<p>cluster3-node2           NotReady   &lt;none&gt;         108s   v1.28.2</p>

<p>Give it a bit of time till the node is ready.</p>

<p>➜ k get node</p>

<p>NAME                     STATUS     ROLES           AGE   VERSION</p>

<p>cluster3-controlplane1   Ready     control-plane   102m   v1.28.2</p>

<p>cluster3-node1           Ready     &lt;none&gt;         97m   v1.28.2</p>

<p>cluster3-node2           Ready     &lt;none&gt;         108s   v1.28.2</p>

<p>We see cluster3-node2 is now available and up to date.</p>

<p> </p>

<p> </p>

<p><strong>Question 21 | Create a Static Pod and Service</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Create a Static Pod named my-static-pod in <em>Namespace</em> default on cluster3-controlplane1. It should be of image nginx:1.16-alpine and have resource requests for 10m CPU and 20Mi memory.</p>

<p>Then create a NodePort <em>Service</em> named static-pod-service which exposes that static <em>Pod</em> on port 80 and check if it has <em>Endpoints</em> and if it's reachable through the cluster3-controlplane1 internal IP address. You can connect to the internal node IPs from your main terminal.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>➜ ssh cluster3-controlplane1</p>

<p>➜ root@cluster1-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>➜ root@cluster1-controlplane1:~# kubectl run my-static-pod \</p>

<p>--image=nginx:1.16-alpine \</p>

<p>-o yaml --dry-run=client &gt; my-static-pod.yaml</p>

<p>Then edit the my-static-pod.yaml to add the requested resource requests:</p>

<p># /etc/kubernetes/manifests/my-static-pod.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: my-static-pod</p>

<p>name: my-static-pod</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.16-alpine</p>

<p>  name: my-static-pod</p>

<p>  resources:</p>

<p>    requests:</p>

<p>      cpu: 10m</p>

<p>      memory: 20Mi</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p> </p>

<p>And make sure it's running:</p>

<p>➜ k get pod -A | grep my-static</p>

<p>NAMESPACE     NAME                             READY   STATUS   ...   AGE</p>

<p>default       my-static-pod-cluster3-controlplane1   1/1     Running ...   22s</p>

<p>Now we expose that static <em>Pod</em>:</p>

<p>k expose pod my-static-pod-cluster3-controlplane1 \</p>

<p>--name static-pod-service \</p>

<p>--type=NodePort \</p>

<p>--port 80</p>

<p>This would generate a <em>Service</em> like:</p>

<p># kubectl expose pod my-static-pod-cluster3-controlplane1 --name static-pod-service --type=NodePort --port 80</p>

<p>apiVersion: v1</p>

<p>kind: Service</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: my-static-pod</p>

<p>name: static-pod-service</p>

<p>spec:</p>

<p>ports:</p>

<p>- port: 80</p>

<p>  protocol: TCP</p>

<p>  targetPort: 80</p>

<p>selector:</p>

<p>  run: my-static-pod</p>

<p>type: NodePort</p>

<p>status:</p>

<p>loadBalancer: {}</p>

<p>Then run and test:</p>

<p>➜ k get svc,ep -l run=my-static-pod</p>

<p>NAME                         TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)       AGE</p>

<p>service/static-pod-service   NodePort   10.99.168.252   &lt;none&gt;       80:30352/TCP   30s</p>

<p>NAME                           ENDPOINTS     AGE</p>

<p>endpoints/static-pod-service   10.32.0.4:80   30s</p>

<p>Looking good.</p>

<p> </p>

<p> </p>

<p><strong>Question 22 | Check how long certificates are valid</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Check how long the kube-apiserver server certificate is valid on cluster2-controlplane1. Do this with openssl or cfssl. Write the exipiration date into /opt/course/22/expiration.</p>

<p>Also run the correct kubeadm command to list the expiration dates and confirm both methods show the same date.</p>

<p>Write the correct kubeadm command that would renew the apiserver server certificate into /opt/course/22/kubeadm-renew-certs.sh.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First let's find that certificate:</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# find /etc/kubernetes/pki | grep apiserver</p>

<p>/etc/kubernetes/pki/apiserver.crt</p>

<p>/etc/kubernetes/pki/apiserver-etcd-client.crt</p>

<p>/etc/kubernetes/pki/apiserver-etcd-client.key</p>

<p>/etc/kubernetes/pki/apiserver-kubelet-client.crt</p>

<p>/etc/kubernetes/pki/apiserver.key</p>

<p>/etc/kubernetes/pki/apiserver-kubelet-client.key</p>

<p>Next we use openssl to find out the expiration date:</p>

<p>➜ root@cluster2-controlplane1:~# openssl x509 -noout -text -in /etc/kubernetes/pki/apiserver.crt | grep Validity -A2</p>

<p>      Validity</p>

<p>          Not Before: Dec 20 18:05:20 2022 GMT</p>

<p>          Not After : Dec 20 18:05:20 2023 GMT</p>

<p>There we have it, so we write it in the required location on our main terminal:</p>

<p># /opt/course/22/expiration</p>

<p>Dec 20 18:05:20 2023 GMT</p>

<p>And we use the feature from kubeadm to get the expiration too:</p>

<p>➜ root@cluster2-controlplane1:~# kubeadm certs check-expiration | grep apiserver</p>

<p>apiserver               Jan 14, 2022 18:49 UTC   363d       ca               no      </p>

<p>apiserver-etcd-client   Jan 14, 2022 18:49 UTC   363d       etcd-ca         no      </p>

<p>apiserver-kubelet-client Jan 14, 2022 18:49 UTC   363d       ca               no</p>

<p>Looking good. And finally we write the command that would renew all certificates into the requested location:</p>

<p># /opt/course/22/kubeadm-renew-certs.sh</p>

<p>kubeadm certs renew apiserver</p>

<p> </p>

<p> </p>

<p><strong>Question 23 | Kubelet client/server cert info</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Node cluster2-node1 has been added to the cluster using kubeadm and TLS bootstrapping.</p>

<p>Find the "Issuer" and "Extended Key Usage" values of the cluster2-node1:</p>

<ol>
  <li>
    <p>kubelet <strong>client</strong> certificate, the one used for outgoing connections to the kube-apiserver.</p>
  </li>
  <li>
    <p>kubelet <strong>server</strong> certificate, the one used for incoming connections from the kube-apiserver.</p>
  </li>
</ol>

<p>Write the information into file /opt/course/23/certificate-info.txt.</p>

<p>Compare the "Issuer" and "Extended Key Usage" fields of both certificates and make sense of these.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>To find the correct kubelet certificate directory, we can look for the default value of the --cert-dir parameter for the kubelet. For this search for "kubelet" in the Kubernetes docs which will lead to: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet">[https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet]{.underline}</a>. We can check if another certificate directory has been configured using ps aux or in /etc/systemd/system/kubelet.service.d/10-kubeadm.conf.</p>

<p>First we check the kubelet client certificate:</p>

<p>➜ ssh cluster2-node1</p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem | grep Issuer</p>

<p>      Issuer: CN = kubernetes</p>

<p>       </p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem | grep "Extended Key Usage" -A1</p>

<p>          X509v3 Extended Key Usage:</p>

<p>              TLS Web Client Authentication</p>

<p>Next we check the kubelet server certificate:</p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet.crt | grep Issuer</p>

<p>Issuer: CN = cluster2-node1-ca@1588186506</p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet.crt | grep "Extended Key Usage" -A1</p>

<p>X509v3 Extended Key Usage:</p>

<p>              TLS Web Server Authentication</p>

<p>We see that the server certificate was generated on the worker node itself and the client certificate was issued by the Kubernetes api. The "Extended Key Usage" also shows if it's for client or server authentication.</p>

<p>More about this: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping">[https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping]{.underline}</a></p>

<p> </p>

<p> </p>

<p><strong>Question 24 | NetworkPolicy</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There was a security incident where an intruder was able to access the whole cluster from a single hacked backend <em>Pod</em>.</p>

<p>To prevent this create a <em>NetworkPolicy</em> called np-backend in <em>Namespace</em> project-snake. It should allow the backend-* <em>Pods</em> only to:</p>

<ul>
  <li>
    <p>connect to db1-* <em>Pods</em> on port 1111</p>
  </li>
  <li>
    <p>connect to db2-* <em>Pods</em> on port 2222</p>
  </li>
</ul>

<p>Use the app label of <em>Pods</em> in your policy.</p>

<p>After implementation, connections from backend-* <em>Pods</em> to vault-* <em>Pods</em> on port 3333 should for example no longer work.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we look at the existing <em>Pods</em> and their labels:</p>

<p>➜ k -n project-snake get pod</p>

<p>NAME       READY   STATUS   RESTARTS   AGE</p>

<p>backend-0   1/1     Running   0         8s</p>

<p>db1-0       1/1     Running   0         8s</p>

<p>db2-0       1/1     Running   0         10s</p>

<p>vault-0     1/1     Running   0         10s</p>

<p>➜ k -n project-snake get pod -L app</p>

<p>NAME       READY   STATUS   RESTARTS   AGE     APP</p>

<p>backend-0   1/1     Running   0         3m15s   backend</p>

<p>db1-0       1/1     Running   0         3m15s   db1</p>

<p>db2-0       1/1     Running   0         3m17s   db2</p>

<p>vault-0     1/1     Running   0         3m17s   vault</p>

<p>We test the current connection situation and see nothing is restricted:</p>

<p>➜ k -n project-snake get pod -o wide</p>

<p>NAME       READY   STATUS   RESTARTS   AGE     IP         ...</p>

<p>backend-0   1/1     Running   0         4m14s   10.44.0.24 ...</p>

<p>db1-0       1/1     Running   0         4m14s   10.44.0.25 ...</p>

<p>db2-0       1/1     Running   0         4m16s   10.44.0.23 ...</p>

<p>vault-0     1/1     Running   0         4m16s   10.44.0.22 ...</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.25:1111</p>

<p>database one</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.23:2222</p>

<p>database two</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.22:3333</p>

<p>vault secret storage</p>

<p>Now we create the <em>NP</em> by copying and chaning an example from the k8s docs:</p>

<p>vim 24_np.yaml</p>

<p># 24_np.yaml</p>

<p>apiVersion: networking.k8s.io/v1</p>

<p>kind: NetworkPolicy</p>

<p>metadata:</p>

<p>name: np-backend</p>

<p>namespace: project-snake</p>

<p>spec:</p>

<p>podSelector:</p>

<p>  matchLabels:</p>

<p>    app: backend</p>

<p>policyTypes:</p>

<p>  - Egress                    # policy is only about Egress</p>

<p>egress:</p>

<p>  -                           # first rule</p>

<p>    to:                           # first condition "to"</p>

<p>    - podSelector:</p>

<p>        matchLabels:</p>

<p>          app: db1</p>

<p>    ports:                        # second condition "port"</p>

<p>    - protocol: TCP</p>

<p>      port: 1111</p>

<p>  -                           # second rule</p>

<p>    to:                           # first condition "to"</p>

<p>    - podSelector:</p>

<p>        matchLabels:</p>

<p>          app: db2</p>

<p>    ports:    # second condition "port"</p>

<p>    - protocol: TCP</p>

<p>      port: 2222</p>

<p>The <em>NP</em> above has two rules with two conditions each, it can be read as:</p>

<p>allow outgoing traffic if:</p>

<p>(destination pod has label app=db1 AND port is 1111)</p>

<p>OR</p>

<p>(destination pod has label app=db2 AND port is 2222)</p>

<p> </p>

<p><strong>Wrong example</strong></p>

<p>Now let's shortly look at a wrong example:</p>

<p># WRONG</p>

<p>apiVersion: networking.k8s.io/v1</p>

<p>kind: NetworkPolicy</p>

<p>metadata:</p>

<p>name: np-backend</p>

<p>namespace: project-snake</p>

<p>spec:</p>

<p>podSelector:</p>

<p>  matchLabels:</p>

<p>    app: backend</p>

<p>policyTypes:</p>

<p>  - Egress</p>

<p>egress:</p>

<p>  -                           # first rule</p>

<p>    to:                           # first condition "to"</p>

<p>    - podSelector:                    # first "to" possibility</p>

<p>        matchLabels:</p>

<p>          app: db1</p>

<p>    - podSelector:                    # second "to" possibility</p>

<p>        matchLabels:</p>

<p>          app: db2</p>

<p>    ports:                        # second condition "ports"</p>

<p>    - protocol: TCP                   # first "ports" possibility</p>

<p>      port: 1111</p>

<p>    - protocol: TCP                   # second "ports" possibility</p>

<p>      port: 2222</p>

<p>The <em>NP</em> above has one rule with two conditions and two condition-entries each, it can be read as:</p>

<p>allow outgoing traffic if:</p>

<p>(destination pod has label app=db1 OR destination pod has label app=db2)</p>

<p>AND</p>

<p>(destination port is 1111 OR destination port is 2222)</p>

<p>Using this <em>NP</em> it would still be possible for backend-* <em>Pods</em> to connect to db2-* <em>Pods</em> on port 1111 for example which should be forbidden.</p>

<p> </p>

<p><strong>Create NetworkPolicy</strong></p>

<p>We create the correct <em>NP</em>:</p>

<p>k -f 24_np.yaml create</p>

<p>And test again:</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.25:1111</p>

<p>database one</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.23:2222</p>

<p>database two</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.22:3333</p>

<p>\^C</p>

<p>Also helpful to use kubectl describe on the <em>NP</em> to see how k8s has interpreted the policy.</p>

<p>Great, looking more secure. Task done.</p>

<p> </p>

<p> </p>

<p><strong>Question 25 | Etcd Snapshot Save and Restore</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Make a backup of etcd running on cluster3-controlplane1 and save it on the controlplane node at /tmp/etcd-backup.db.</p>

<p>Then create any kind of <em>Pod</em> in the cluster.</p>

<p>Finally restore the backup, confirm the cluster is still working and that the created <em>Pod</em> is no longer with us.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Etcd Backup</strong></p>

<p>First we log into the controlplane and try to create a snapshop of etcd:</p>

<p>➜ ssh cluster3-controlplane1</p>

<p>➜ root@cluster3-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd-backup.db</p>

<p>Error: rpc error: code = Unavailable desc = transport is closing</p>

<p>But it fails because we need to authenticate ourselves. For the necessary information we can check the etc manifest:</p>

<p>➜ root@cluster3-controlplane1:~# vim /etc/kubernetes/manifests/etcd.yaml</p>

<p>We only check the etcd.yaml for necessary information we don't change it.</p>

<p># /etc/kubernetes/manifests/etcd.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: etcd</p>

<p>  tier: control-plane</p>

<p>name: etcd</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - etcd</p>

<p>  - --advertise-client-urls=https://192.168.100.31:2379</p>

<p>  - --cert-file=/etc/kubernetes/pki/etcd/server.crt # use</p>

<p>  - --client-cert-auth=true</p>

<p>  - --data-dir=/var/lib/etcd</p>

<p>  - --initial-advertise-peer-urls=https://192.168.100.31:2380</p>

<p>  - --initial-cluster=cluster3-controlplane1=https://192.168.100.31:2380</p>

<p>  - --key-file=/etc/kubernetes/pki/etcd/server.key # use</p>

<p>  - --listen-client-urls=https://127.0.0.1:2379,https://192.168.100.31:2379 # use</p>

<p>  - --listen-metrics-urls=http://127.0.0.1:2381</p>

<p>  - --listen-peer-urls=https://192.168.100.31:2380</p>

<p>  - --name=cluster3-controlplane1</p>

<p>  - --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt</p>

<p>  - --peer-client-cert-auth=true</p>

<p>  - --peer-key-file=/etc/kubernetes/pki/etcd/peer.key</p>

<p>  - --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt # use</p>

<p>  - --snapshot-count=10000</p>

<p>  - --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>  image: k8s.gcr.io/etcd:3.3.15-0</p>

<p>  imagePullPolicy: IfNotPresent</p>

<p>  livenessProbe:</p>

<p>    failureThreshold: 8</p>

<p>    httpGet:</p>

<p>      host: 127.0.0.1</p>

<p>      path: /health</p>

<p>      port: 2381</p>

<p>      scheme: HTTP</p>

<p>    initialDelaySeconds: 15</p>

<p>    timeoutSeconds: 15</p>

<p>  name: etcd</p>

<p>  resources: {}</p>

<p>  volumeMounts:</p>

<p>  - mountPath: /var/lib/etcd</p>

<p>    name: etcd-data</p>

<p>  - mountPath: /etc/kubernetes/pki/etcd</p>

<p>    name: etcd-certs</p>

<p>hostNetwork: true</p>

<p>priorityClassName: system-cluster-critical</p>

<p>volumes:</p>

<p>- hostPath:</p>

<p>    path: /etc/kubernetes/pki/etcd</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-certs</p>

<p>- hostPath:</p>

<p>    path: /var/lib/etcd # important</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-data</p>

<p>status: {}</p>

<p>But we also know that the api-server is connecting to etcd, so we can check how its manifest is configured:</p>

<p>➜ root@cluster3-controlplane1:~# cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd</p>

<p>  - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>  - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt</p>

<p>  - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key</p>

<p>  - --etcd-servers=https://127.0.0.1:2379</p>

<p>We use the authentication information and pass it to etcdctl:</p>

<p>➜ root@cluster3-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd-backup.db \</p>

<p>--cacert /etc/kubernetes/pki/etcd/ca.crt \</p>

<p>--cert /etc/kubernetes/pki/etcd/server.crt \</p>

<p>--key /etc/kubernetes/pki/etcd/server.key</p>

<p>Snapshot saved at /tmp/etcd-backup.db</p>

<p> </p>

<p><strong>NOTE:</strong> Dont use snapshot status because it can alter the snapshot file and render it invalid</p>

<p> </p>

<p><strong>Etcd restore</strong></p>

<p>Now create a <em>Pod</em> in the cluster and wait for it to be running:</p>

<p>➜ root@cluster3-controlplane1:~# kubectl run test --image=nginx</p>

<p>pod/test created</p>

<p>➜ root@cluster3-controlplane1:~# kubectl get pod -l run=test -w</p>

<p>NAME   READY   STATUS   RESTARTS   AGE</p>

<p>test   1/1     Running   0         60s</p>

<p> </p>

<p><strong>NOTE:</strong> If you didn't solve questions 18 or 20 and cluster3 doesn't have a ready worker node then the created pod might stay in a Pending state. This is still ok for this task.</p>

<p> </p>

<p>Next we stop all controlplane components:</p>

<p>root@cluster3-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# mv * ..</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# watch crictl ps</p>

<p>Now we restore the snapshot into a specific directory:</p>

<p>➜ root@cluster3-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot restore /tmp/etcd-backup.db \</p>

<p>--data-dir /var/lib/etcd-backup \</p>

<p>--cacert /etc/kubernetes/pki/etcd/ca.crt \</p>

<p>--cert /etc/kubernetes/pki/etcd/server.crt \</p>

<p>--key /etc/kubernetes/pki/etcd/server.key</p>

<p>2020-09-04 16:50:19.650804 I | mvcc: restore compact to 9935</p>

<p>2020-09-04 16:50:19.659095 I | etcdserver/membership: added member 8e9e05c52164694d [http://localhost:2380] to cluster cdf818194e3a8c32</p>

<p>We could specify another host to make the backup from by using etcdctl --endpoints http://IP, but here we just use the default value which is: http://127.0.0.1:2379,http://127.0.0.1:4001.</p>

<p>The restored files are located at the new folder /var/lib/etcd-backup, now we have to tell etcd to use that directory:</p>

<p>➜ root@cluster3-controlplane1:~# vim /etc/kubernetes/etcd.yaml</p>

<p># /etc/kubernetes/etcd.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: etcd</p>

<p>  tier: control-plane</p>

<p>name: etcd</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>...</p>

<p>  - mountPath: /etc/kubernetes/pki/etcd</p>

<p>    name: etcd-certs</p>

<p>hostNetwork: true</p>

<p>priorityClassName: system-cluster-critical</p>

<p>volumes:</p>

<p>- hostPath:</p>

<p>    path: /etc/kubernetes/pki/etcd</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-certs</p>

<p>- hostPath:</p>

<p>    path: /var/lib/etcd-backup # change</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-data</p>

<p>status: {}</p>

<p>Now we move all controlplane yaml again into the manifest directory. Give it some time (up to several minutes) for etcd to restart and for the api-server to be reachable again:</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# mv ../*.yaml .</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# watch crictl ps</p>

<p>Then we check again for the <em>Pod</em>:</p>

<p>➜ root@cluster3-controlplane1:~# kubectl get pod -l run=test</p>

<p>No resources found in default namespace.</p>

<p>Awesome, backup and restore worked as our pod is gone.</p>

<p> </p>

<p> </p>

<p><strong>Extra Question 1 | Find Pods first to be terminated</strong></p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Check all available <em>Pods</em> in the <em>Namespace</em> project-c13 and find the names of those that would probably be terminated first if the <em>nodes</em> run out of resources (cpu or memory) to schedule all <em>Pods</em>. Write the <em>Pod</em> names into /opt/course/e1/pods-not-stable.txt.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>When available cpu or memory resources on the nodes reach their limit, Kubernetes will look for <em>Pods</em> that are using more resources than they requested. These will be the first candidates for termination. If some <em>Pods</em> containers have no resource requests/limits set, then by default those are considered to use more than requested.</p>

<p>Kubernetes assigns Quality of Service classes to <em>Pods</em> based on the defined resources and limits, read more here: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod">[https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod]{.underline}</a></p>

<p>Hence we should look for <em>Pods</em> without resource requests defined, we can do this with a manual approach:</p>

<p>k -n project-c13 describe pod | less -p Requests # describe all pods and highlight Requests</p>

<p>Or we do:</p>

<p>k -n project-c13 describe pod | egrep "\^(Name:|   Requests:)" -A1</p>

<p>We see that the <em>Pods</em> of <em>Deployment</em> c13-3cc-runner-heavy don't have any resources requests specified. Hence our answer would be:</p>

<p># /opt/course/e1/pods-not-stable.txt</p>

<p>c13-3cc-runner-heavy-65588d7d6-djtv9map</p>

<p>c13-3cc-runner-heavy-65588d7d6-v8kf5map</p>

<p>c13-3cc-runner-heavy-65588d7d6-wwpb4map</p>

<p>o3db-0</p>

<p>o3db-1 # maybe not existing if already removed via previous scenario</p>

<p>To automate this process you could use jsonpath like this:</p>

<p>➜ k -n project-c13 get pod \</p>

<p>-o jsonpath="{range .items[*]} {.metadata.name}{.spec.containers[*].resources}{'\n'}"</p>

<p>c13-2x3-api-86784557bd-cgs8gmap[requests:map[cpu:50m memory:20Mi]]</p>

<p>c13-2x3-api-86784557bd-lnxvjmap[requests:map[cpu:50m memory:20Mi]]</p>

<p>c13-2x3-api-86784557bd-mnp77map[requests:map[cpu:50m memory:20Mi]]</p>

<p>c13-2x3-web-769c989898-6hbgtmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-g57nqmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-hfd5vmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-jfx64map[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-r89mgmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-wtgxlmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-runner-98c8b5469-dzqhrmap[requests:map[cpu:30m memory:10Mi]]</p>

<p>c13-3cc-runner-98c8b5469-hbtdvmap[requests:map[cpu:30m memory:10Mi]]</p>

<p>c13-3cc-runner-98c8b5469-n9lswmap[requests:map[cpu:30m memory:10Mi]]</p>

<p>c13-3cc-runner-heavy-65588d7d6-djtv9map[]</p>

<p>c13-3cc-runner-heavy-65588d7d6-v8kf5map[]</p>

<p>c13-3cc-runner-heavy-65588d7d6-wwpb4map[]</p>

<p>c13-3cc-web-675456bcd-glpq6map[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-web-675456bcd-knlpxmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-web-675456bcd-nfhp9map[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-web-675456bcd-twn7mmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>o3db-0{}</p>

<p>o3db-1{}</p>

<p>This lists all <em>Pod</em> names and their requests/limits, hence we see the three <em>Pods</em> without those defined.</p>

<p>Or we look for the Quality of Service classes:</p>

<p>➜ k get pods -n project-c13 \</p>

<p>-o jsonpath="{range .items[*]}{.metadata.name} {.status.qosClass}{'\n'}"</p>

<p>c13-2x3-api-86784557bd-cgs8g Burstable</p>

<p>c13-2x3-api-86784557bd-lnxvj Burstable</p>

<p>c13-2x3-api-86784557bd-mnp77 Burstable</p>

<p>c13-2x3-web-769c989898-6hbgt Burstable</p>

<p>c13-2x3-web-769c989898-g57nq Burstable</p>

<p>c13-2x3-web-769c989898-hfd5v Burstable</p>

<p>c13-2x3-web-769c989898-jfx64 Burstable</p>

<p>c13-2x3-web-769c989898-r89mg Burstable</p>

<p>c13-2x3-web-769c989898-wtgxl Burstable</p>

<p>c13-3cc-runner-98c8b5469-dzqhr Burstable</p>

<p>c13-3cc-runner-98c8b5469-hbtdv Burstable</p>

<p>c13-3cc-runner-98c8b5469-n9lsw Burstable</p>

<p>c13-3cc-runner-heavy-65588d7d6-djtv9 BestEffort</p>

<p>c13-3cc-runner-heavy-65588d7d6-v8kf5 BestEffort</p>

<p>c13-3cc-runner-heavy-65588d7d6-wwpb4 BestEffort</p>

<p>c13-3cc-web-675456bcd-glpq6 Burstable</p>

<p>c13-3cc-web-675456bcd-knlpx Burstable</p>

<p>c13-3cc-web-675456bcd-nfhp9 Burstable</p>

<p>c13-3cc-web-675456bcd-twn7m Burstable</p>

<p>o3db-0 BestEffort</p>

<p>o3db-1 BestEffort</p>

<p>Here we see three with BestEffort, which <em>Pods</em> get that don't have any memory or cpu limits or requests defined.</p>

<p>A good practice is to always set resource requests and limits. If you don't know the values your containers should have you can find this out using metric tools like Prometheus. You can also use kubectl top pod or even kubectl exec into the container and use top and similar tools.</p>

<p> </p>

<p> </p>

<p><strong>Extra Question 2 | Curl Manually Contact API</strong></p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There is an existing <em>ServiceAccount</em> secret-reader in <em>Namespace</em> project-hamster. Create a <em>Pod</em> of image curlimages/curl:7.65.3 named tmp-api-contact which uses this <em>ServiceAccount</em>. Make sure the container keeps running.</p>

<p>Exec into the <em>Pod</em> and use curl to access the Kubernetes Api of that cluster manually, listing all available secrets. You can ignore insecure https connection. Write the command(s) for this into file /opt/course/e4/list-secrets.sh.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><a href="https://kubernetes.io/docs/tasks/run-application/access-api-from-pod">[https://kubernetes.io/docs/tasks/run-application/access-api-from-pod]{.underline}</a></p>

<p>It's important to understand how the Kubernetes API works. For this it helps connecting to the api manually, for example using curl. You can find information fast by search in the Kubernetes docs for "curl api" for example.</p>

<p>First we create our <em>Pod</em>:</p>

<p>k run tmp-api-contact \</p>

<p>--image=curlimages/curl:7.65.3 $do \</p>

<p>--command &gt; e2.yaml -- sh -c 'sleep 1d'</p>

<p>vim e2.yaml</p>

<p>Add the service account name and <em>Namespace</em>:</p>

<p># e2.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: tmp-api-contact</p>

<p>name: tmp-api-contact</p>

<p>namespace: project-hamster # add</p>

<p>spec:</p>

<p>serviceAccountName: secret-reader # add</p>

<p>containers:</p>

<p>- command:</p>

<p>  - sh</p>

<p>  - -c</p>

<p>  - sleep 1d</p>

<p>  image: curlimages/curl:7.65.3</p>

<p>  name: tmp-api-contact</p>

<p>  resources: {}</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p>Then run and exec into:</p>

<p>k -f 6.yaml create</p>

<p>k -n project-hamster exec tmp-api-contact -it -- sh</p>

<p>Once on the container we can try to connect to the api using curl, the api is usually available via the <em>Service</em> named kubernetes in <em>Namespace</em> default (You should know how dns resolution works across <em>Namespaces</em>.). Else we can find the endpoint IP via environment variables running env.</p>

<p>So now we can do:</p>

<p>curl https://kubernetes.default</p>

<p>curl -k https://kubernetes.default # ignore insecure as allowed in ticket description</p>

<p>curl -k https://kubernetes.default/api/v1/secrets # should show Forbidden 403</p>

<p>The last command shows 403 forbidden, this is because we are not passing any authorisation information with us. The Kubernetes Api Server thinks we are connecting as system:anonymous. We want to change this and connect using the <em>Pods</em> <em>ServiceAccount</em> named secret-reader.</p>

<p>We find the the token in the mounted folder at /var/run/secrets/kubernetes.io/serviceaccount, so we do:</p>

<p>➜ TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)</p>

<p>➜ curl -k https://kubernetes.default/api/v1/secrets -H "Authorization: Bearer ${TOKEN}"</p>

<p>\% Total   % Received % Xferd Average Speed   Time   Time     Time Current</p>

<p>                                Dload Upload   Total   Spent   Left Speed</p>

<p>0     0   0     0   0     0     0     0 --:--:-- --:--:-- --:--:--     0{</p>

<p>"kind": "SecretList",</p>

<p>"apiVersion": "v1",</p>

<p>"metadata": {</p>

<p>  "selfLink": "/api/v1/secrets",</p>

<p>  "resourceVersion": "10697"</p>

<p>},</p>

<p>"items": [</p>

<p>  {</p>

<p>    "metadata": {</p>

<p>      "name": "default-token-5zjbd",</p>

<p>      "namespace": "default",</p>

<p>      "selfLink": "/api/v1/namespaces/default/secrets/default-token-5zjbd",</p>

<p>      "uid": "315dbfd9-d235-482b-8bfc-c6167e7c1461",</p>

<p>      "resourceVersion": "342",</p>

<p>...</p>

<p>Now we're able to list all <em>Secrets</em>, registering as the <em>ServiceAccount</em> secret-reader under which our <em>Pod</em> is running.</p>

<p>To use encrypted https connection we can run:</p>

<p>CACERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</p>

<p>curl --cacert ${CACERT} https://kubernetes.default/api/v1/secrets -H "Authorization: Bearer ${TOKEN}"</p>

<p>For troubleshooting we could also check if the <em>ServiceAccount</em> is actually able to list <em>Secrets</em> using:</p>

<p>➜ k auth can-i get secret --as system:serviceaccount:project-hamster:secret-reader</p>

<p>yes</p>

<p>Finally write the commands into the requested location:</p>

<p># /opt/course/e4/list-secrets.sh</p>

<p>TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)</p>

<p>curl -k https://kubernetes.default/api/v1/secrets -H "Authorization: Bearer ${TOKEN}"</p>

<p> </p>

<p> </p>

<p><strong>CKA Simulator Preview Kubernetes 1.28</strong></p>

<p><a href="https://killer.sh/">[https://killer.sh]{.underline}</a></p>

<p>This is a preview of the full CKA Simulator course content.</p>

<p>The full course contains 25 scenarios from all the CKA areas. The course also provides a browser terminal which is a very close replica of the original one. This is great to get used and comfortable before the real exam. After the test session (120 minutes), or if you stop it early, you'll get access to all questions and their detailed solutions. You'll have 36 hours cluster access in total which means even after the session, once you have the solutions, you can still play around.</p>

<p>The following preview will give you an idea of what the full course will provide. These preview questions are in addition to the 25 of the full course. But the preview questions are part of the same CKA simulation environment which we setup for you, so with access to the full course you can solve these too.</p>

<p>The answers provided here assume that you did run the initial terminal setup suggestions as provided in the tips section, but especially:</p>

<p>alias k=kubectl</p>

<p>export do="-o yaml --dry-run=client"</p>

<p> </p>

<p><strong>These questions can be solved in the test environment provided through the CKA Simulator</strong></p>

<p> </p>

<p><strong>Preview Question 1</strong></p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p>The cluster admin asked you to find out the following information about etcd running on cluster2-controlplane1:</p>

<ul>
  <li>
    <p>Server private key location</p>
  </li>
  <li>
    <p>Server certificate expiration date</p>
  </li>
  <li>
    <p>Is client certificate authentication enabled</p>
  </li>
</ul>

<p>Write these information into /opt/course/p1/etcd-info.txt</p>

<p>Finally you're asked to save an etcd snapshot at /etc/etcd-snapshot.db on cluster2-controlplane1 and display its status.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Find out etcd information</strong></p>

<p>Let's check the nodes:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster2-controlplane1   Ready   control-plane   89m   v1.28.2</p>

<p>cluster2-node1           Ready   &lt;none&gt;         87m   v1.28.2</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>First we check how etcd is setup in this cluster:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod</p>

<p>NAME                                               READY   STATUS   RESTARTS   AGE</p>

<p>coredns-66bff467f8-k8f48                           1/1     Running   0         26h</p>

<p>coredns-66bff467f8-rn8tr                           1/1     Running   0         26h</p>

<p>etcd-cluster2-controlplane1                         1/1     Running   0         26h</p>

<p>kube-apiserver-cluster2-controlplane1               1/1     Running   0         26h</p>

<p>kube-controller-manager-cluster2-controlplane1     1/1     Running   0         26h</p>

<p>kube-proxy-qthfg                                   1/1     Running   0         25h</p>

<p>kube-proxy-z55lp                                   1/1     Running   0         26h</p>

<p>kube-scheduler-cluster2-controlplane1               1/1     Running   1         26h</p>

<p>weave-net-cqdvt                                     2/2     Running   0         26h</p>

<p>weave-net-dxzgh                                     2/2     Running   1         25h</p>

<p>We see it's running as a <em>Pod</em>, more specific a static <em>Pod</em>. So we check for the default kubelet directory for static manifests:</p>

<p>➜ root@cluster2-controlplane1:~# find /etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p>/etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p>/etc/kubernetes/manifests/etcd.yaml</p>

<p>/etc/kubernetes/manifests/kube-scheduler.yaml</p>

<p>➜ root@cluster2-controlplane1:~# vim /etc/kubernetes/manifests/etcd.yaml</p>

<p>So we look at the yaml and the parameters with which etcd is started:</p>

<p># /etc/kubernetes/manifests/etcd.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: etcd</p>

<p>  tier: control-plane</p>

<p>name: etcd</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - etcd</p>

<p>  - --advertise-client-urls=https://192.168.102.11:2379</p>

<p>  - --cert-file=/etc/kubernetes/pki/etcd/server.crt              # server certificate</p>

<p>  - --client-cert-auth=true                                      # enabled</p>

<p>  - --data-dir=/var/lib/etcd</p>

<p>  - --initial-advertise-peer-urls=https://192.168.102.11:2380</p>

<p>  - --initial-cluster=cluster2-controlplane1=https://192.168.102.11:2380</p>

<p>  - --key-file=/etc/kubernetes/pki/etcd/server.key               # server private key</p>

<p>  - --listen-client-urls=https://127.0.0.1:2379,https://192.168.102.11:2379</p>

<p>  - --listen-metrics-urls=http://127.0.0.1:2381</p>

<p>  - --listen-peer-urls=https://192.168.102.11:2380</p>

<p>  - --name=cluster2-controlplane1</p>

<p>  - --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt</p>

<p>  - --peer-client-cert-auth=true</p>

<p>  - --peer-key-file=/etc/kubernetes/pki/etcd/peer.key</p>

<p>  - --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>  - --snapshot-count=10000</p>

<p>  - --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>...</p>

<p>We see that client authentication is enabled and also the requested path to the server private key, now let's find out the expiration of the server certificate:</p>

<p>➜ root@cluster2-controlplane1:~# openssl x509 -noout -text -in /etc/kubernetes/pki/etcd/server.crt | grep Validity -A2</p>

<p>      Validity</p>

<p>          Not Before: Sep 13 13:01:31 2021 GMT</p>

<p>          Not After : Sep 13 13:01:31 2022 GMT</p>

<p>There we have it. Let's write the information into the requested file:</p>

<p># /opt/course/p1/etcd-info.txt</p>

<p>Server private key location: /etc/kubernetes/pki/etcd/server.key</p>

<p>Server certificate expiration date: Sep 13 13:01:31 2022 GMT</p>

<p>Is client certificate authentication enabled: yes</p>

<p> </p>

<p><strong>Create etcd snapshot</strong></p>

<p>First we try:</p>

<p>ETCDCTL_API=3 etcdctl snapshot save /etc/etcd-snapshot.db</p>

<p>We get the endpoint also from the yaml. But we need to specify more parameters, all of which we can find the yaml declaration above:</p>

<p>ETCDCTL_API=3 etcdctl snapshot save /etc/etcd-snapshot.db \</p>

<p>--cacert /etc/kubernetes/pki/etcd/ca.crt \</p>

<p>--cert /etc/kubernetes/pki/etcd/server.crt \</p>

<p>--key /etc/kubernetes/pki/etcd/server.key</p>

<p>This worked. Now we can output the status of the backup file:</p>

<p>➜ root@cluster2-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot status /etc/etcd-snapshot.db</p>

<p>4d4e953, 7213, 1291, 2.7 MB</p>

<p>The status shows:</p>

<ul>
  <li>
    <p>Hash: 4d4e953</p>
  </li>
  <li>
    <p>Revision: 7213</p>
  </li>
  <li>
    <p>Total Keys: 1291</p>
  </li>
  <li>
    <p>Total Size: 2.7 MB</p>
  </li>
</ul>

<p> </p>

<p> </p>

<p><strong>Preview Question 2</strong></p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>You're asked to confirm that kube-proxy is running correctly on all nodes. For this perform the following in <em>Namespace</em> project-hamster:</p>

<p>Create a new <em>Pod</em> named p2-pod with two containers, one of image nginx:1.21.3-alpine and one of image busybox:1.31. Make sure the busybox container keeps running for some time.</p>

<p>Create a new <em>Service</em> named p2-service which exposes that <em>Pod</em> internally in the cluster on port 3000-&gt;80.</p>

<p>Find the kube-proxy container on all nodes cluster1-controlplane1, cluster1-node1 and cluster1-node2 and make sure that it's using iptables. Use command crictl for this.</p>

<p>Write the iptables rules of all nodes belonging the created <em>Service</em> p2-service into file /opt/course/p2/iptables.txt.</p>

<p>Finally delete the <em>Service</em> and confirm that the iptables rules are gone from all nodes.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Create the <em>Pod</em></strong></p>

<p>First we create the <em>Pod</em>:</p>

<p># check out export statement on top which allows us to use $do</p>

<p>k run p2-pod --image=nginx:1.21.3-alpine $do &gt; p2.yaml</p>

<p>vim p2.yaml</p>

<p>Next we add the requested second container:</p>

<p># p2.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: p2-pod</p>

<p>name: p2-pod</p>

<p>namespace: project-hamster             # add</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.21.3-alpine</p>

<p>  name: p2-pod</p>

<p>- image: busybox:1.31                  # add</p>

<p>  name: c2                             # add</p>

<p>  command: ["sh", "-c", "sleep 1d"]    # add</p>

<p>  resources: {}</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p>And we create the <em>Pod</em>:</p>

<p>k -f p2.yaml create</p>

<p> </p>

<p><strong>Create the <em>Service</em></strong></p>

<p>Next we create the <em>Service</em>:</p>

<p>k -n project-hamster expose pod p2-pod --name p2-service --port 3000 --target-port 80</p>

<p>This will create a yaml like:</p>

<p>apiVersion: v1</p>

<p>kind: Service</p>

<p>metadata:</p>

<p>creationTimestamp: "2020-04-30T20:58:14Z"</p>

<p>labels:</p>

<p>  run: p2-pod</p>

<p>managedFields:</p>

<p>...</p>

<p>  operation: Update</p>

<p>  time: "2020-04-30T20:58:14Z"</p>

<p>name: p2-service</p>

<p>namespace: project-hamster</p>

<p>resourceVersion: "11071"</p>

<p>selfLink: /api/v1/namespaces/project-hamster/services/p2-service</p>

<p>uid: 2a1c0842-7fb6-4e94-8cdb-1602a3b1e7d2</p>

<p>spec:</p>

<p>clusterIP: 10.97.45.18</p>

<p>ports:</p>

<p>- port: 3000</p>

<p>  protocol: TCP</p>

<p>  targetPort: 80</p>

<p>selector:</p>

<p>  run: p2-pod</p>

<p>sessionAffinity: None</p>

<p>type: ClusterIP</p>

<p>status:</p>

<p>loadBalancer: {}</p>

<p>We should confirm <em>Pods</em> and <em>Services</em> are connected, hence the <em>Service</em> should have <em>Endpoints</em>.</p>

<p>k -n project-hamster get pod,svc,ep</p>

<p> </p>

<p><strong>Confirm kube-proxy is running and is using iptables</strong></p>

<p>First we get nodes in the cluster:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster1-controlplane1   Ready   control-plane   98m   v1.28.2</p>

<p>cluster1-node1           Ready   &lt;none&gt;         96m   v1.28.2</p>

<p>cluster1-node2           Ready   &lt;none&gt;         95m   v1.28.2</p>

<p>The idea here is to log into every node, find the kube-proxy container and check its logs:</p>

<p>➜ ssh cluster1-controlplane1</p>

<p>➜ root@cluster1-controlplane1$ crictl ps | grep kube-proxy</p>

<p>27b6a18c0f89c       36c4ebbc9d979       3 hours ago         Running             kube-proxy</p>

<p>➜ root@cluster1-controlplane1~# crictl logs 27b6a18c0f89c</p>

<p>...</p>

<p>I0913 12:53:03.096620       1 server_others.go:212] Using iptables Proxier.</p>

<p>...</p>

<p>This should be repeated on every node and result in the same output Using iptables Proxier.</p>

<p> </p>

<p><strong>Check kube-proxy is creating iptables rules</strong></p>

<p>Now we check the iptables rules on every node first manually:</p>

<p>➜ ssh cluster1-controlplane1 iptables-save | grep p2-service</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -s 10.44.0.20/32 -m comment --comment "project-hamster/p2-service:" -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -p tcp -m comment --comment "project-hamster/p2-service:" -m tcp -j DNAT --to-destination 10.44.0.20:80</p>

<p>-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SERVICES -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-SVC-2A6FNMCK6FDH7PJH</p>

<p>-A KUBE-SVC-2A6FNMCK6FDH7PJH -m comment --comment "project-hamster/p2-service:" -j KUBE-SEP-6U447UXLLQIKP7BB</p>

<p>➜ ssh cluster1-node1 iptables-save | grep p2-service</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -s 10.44.0.20/32 -m comment --comment "project-hamster/p2-service:" -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -p tcp -m comment --comment "project-hamster/p2-service:" -m tcp -j DNAT --to-destination 10.44.0.20:80</p>

<p>-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SERVICES -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-SVC-2A6FNMCK6FDH7PJH</p>

<p>-A KUBE-SVC-2A6FNMCK6FDH7PJH -m comment --comment "project-hamster/p2-service:" -j KUBE-SEP-6U447UXLLQIKP7BB</p>

<p>➜ ssh cluster1-node2 iptables-save | grep p2-service</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -s 10.44.0.20/32 -m comment --comment "project-hamster/p2-service:" -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -p tcp -m comment --comment "project-hamster/p2-service:" -m tcp -j DNAT --to-destination 10.44.0.20:80</p>

<p>-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SERVICES -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-SVC-2A6FNMCK6FDH7PJH</p>

<p>-A KUBE-SVC-2A6FNMCK6FDH7PJH -m comment --comment "project-hamster/p2-service:" -j KUBE-SEP-6U447UXLLQIKP7BB</p>

<p>Great. Now let's write these logs into the requested file:</p>

<p>➜ ssh cluster1-controlplane1 iptables-save | grep p2-service &gt;&gt; /opt/course/p2/iptables.txt</p>

<p>➜ ssh cluster1-node1 iptables-save | grep p2-service &gt;&gt; /opt/course/p2/iptables.txt</p>

<p>➜ ssh cluster1-node2 iptables-save | grep p2-service &gt;&gt; /opt/course/p2/iptables.txt</p>

<p> </p>

<p><strong>Delete the <em>Service</em> and confirm iptables rules are gone</strong></p>

<p>Delete the <em>Service</em>:</p>

<p>k -n project-hamster delete svc p2-service</p>

<p>And confirm the iptables rules are gone:</p>

<p>➜ ssh cluster1-controlplane1 iptables-save | grep p2-service</p>

<p>➜ ssh cluster1-node1 iptables-save | grep p2-service</p>

<p>➜ ssh cluster1-node2 iptables-save | grep p2-service</p>

<p>Done.</p>

<p>Kubernetes <em>Services</em> are implemented using iptables rules (with default config) on all nodes. Every time a <em>Service</em> has been altered, created, deleted or <em>Endpoints</em> of a <em>Service</em> have changed, the kube-apiserver contacts every node's kube-proxy to update the iptables rules according to the current state.</p>

<p> </p>

<p> </p>

<p><strong>Preview Question 3</strong></p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Create a <em>Pod</em> named check-ip in <em>Namespace</em> default using image httpd:2.4.41-alpine. Expose it on port 80 as a ClusterIP <em>Service</em> named check-ip-service. Remember/output the IP of that <em>Service</em>.</p>

<p>Change the Service CIDR to 11.96.0.0/12 for the cluster.</p>

<p>Then create a second <em>Service</em> named check-ip-service2 pointing to the same <em>Pod</em> to check if your settings did take effect. Finally check if the IP of the first <em>Service</em> has changed.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>Let's create the <em>Pod</em> and expose it:</p>

<p>k run check-ip --image=httpd:2.4.41-alpine</p>

<p>k expose pod check-ip --name check-ip-service --port 80</p>

<p>And check the <em>Pod</em> and <em>Service</em> ips:</p>

<p>➜ k get svc,ep -l run=check-ip</p>

<p>NAME                       TYPE       CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</p>

<p>service/check-ip-service   ClusterIP   10.104.3.45   &lt;none&gt;       80/TCP   8s</p>

<p>NAME                         ENDPOINTS     AGE</p>

<p>endpoints/check-ip-service   10.44.0.3:80   7s</p>

<p>Now we change the <em>Service</em> CIDR on the kube-apiserver:</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# vim /etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p># /etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: kube-apiserver</p>

<p>  tier: control-plane</p>

<p>name: kube-apiserver</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - kube-apiserver</p>

<p>  - --advertise-address=192.168.100.21</p>

<p>...</p>

<p>  - --service-account-key-file=/etc/kubernetes/pki/sa.pub</p>

<p>  - --service-cluster-ip-range=11.96.0.0/12 # change</p>

<p>  - --tls-cert-file=/etc/kubernetes/pki/apiserver.crt</p>

<p>  - --tls-private-key-file=/etc/kubernetes/pki/apiserver.key</p>

<p>...</p>

<p><strong>Give it a bit for the kube-apiserver and controller-manager to restart</strong></p>

<p>Wait for the api to be up again:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep api</p>

<p>kube-apiserver-cluster2-controlplane1           1/1     Running   0             49s</p>

<p> </p>

<p> </p>

<p>Now we do the same for the controller manager:</p>

<p>➜ root@cluster2-controlplane1:~# vim /etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p># /etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: kube-controller-manager</p>

<p>  tier: control-plane</p>

<p>name: kube-controller-manager</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - kube-controller-manager</p>

<p>  - --allocate-node-cidrs=true</p>

<p>  - --authentication-kubeconfig=/etc/kubernetes/controller-manager.conf</p>

<p>  - --authorization-kubeconfig=/etc/kubernetes/controller-manager.conf</p>

<p>  - --bind-address=127.0.0.1</p>

<p>  - --client-ca-file=/etc/kubernetes/pki/ca.crt</p>

<p>  - --cluster-cidr=10.244.0.0/16</p>

<p>  - --cluster-name=kubernetes</p>

<p>  - --cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt</p>

<p>  - --cluster-signing-key-file=/etc/kubernetes/pki/ca.key</p>

<p>  - --controllers=*,bootstrapsigner,tokencleaner</p>

<p>  - --kubeconfig=/etc/kubernetes/controller-manager.conf</p>

<p>  - --leader-elect=true</p>

<p>  - --node-cidr-mask-size=24</p>

<p>  - --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt</p>

<p>  - --root-ca-file=/etc/kubernetes/pki/ca.crt</p>

<p>  - --service-account-private-key-file=/etc/kubernetes/pki/sa.key</p>

<p>  - --service-cluster-ip-range=11.96.0.0/12 # change</p>

<p>  - --use-service-account-credentials=true</p>

<p><strong>Give it a bit for the scheduler to restart</strong>.</p>

<p>We can check if it was restarted using crictl:</p>

<p>➜ root@cluster2-controlplane1:~# crictl ps | grep scheduler</p>

<p>3d258934b9fd6   aca5ededae9c8   About a minute ago   Running   kube-scheduler ...</p>

<p> </p>

<p> </p>

<p>Checking our existing <em>Pod</em> and <em>Service</em> again:</p>

<p>➜ k get pod,svc -l run=check-ip</p>

<p>NAME           READY   STATUS   RESTARTS   AGE</p>

<p>pod/check-ip   1/1     Running   0         21m</p>

<p>NAME                       TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</p>

<p>service/check-ip-service   ClusterIP   10.99.32.177   &lt;none&gt;       80/TCP   21m</p>

<p>Nothing changed so far. Now we create another <em>Service</em> like before:</p>

<p>k expose pod check-ip --name check-ip-service2 --port 80</p>

<p>And check again:</p>

<p>➜ k get svc,ep -l run=check-ip</p>

<p>NAME                       TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</p>

<p>service/check-ip-service   ClusterIP   10.109.222.111   &lt;none&gt;       80/TCP   8m</p>

<p>service/check-ip-service2   ClusterIP   11.111.108.194   &lt;none&gt;       80/TCP   6m32s</p>

<p>NAME                         ENDPOINTS     AGE</p>

<p>endpoints/check-ip-service   10.44.0.1:80   8m</p>

<p>endpoints/check-ip-service2   10.44.0.1:80   6m13s</p>

<p>There we go, the new <em>Service</em> got an ip of the new specified range assigned. We also see that both <em>Services</em> have our <em>Pod</em> as endpoint.</p>

<p> </p>

<p><strong>CKA Tips Kubernetes 1.28</strong></p>

<p>In this section we'll provide some tips on how to handle the CKA exam and browser terminal.</p>

<p> </p>

<p><strong>Knowledge</strong></p>

<p>Study all topics as proposed in the curriculum till you feel comfortable with all.</p>

<p> </p>

<p><strong>General</strong></p>

<ul>
  <li>
    <p>Study all topics as proposed in the curriculum till you feel comfortable with all</p>
  </li>
  <li>
    <p>Do 1 or 2 test session with this CKA Simulator. Understand the solutions and maybe try out other ways to achieve the same thing.</p>
  </li>
  <li>
    <p>Setup your aliases, be fast and breath kubectl</p>
  </li>
  <li>
    <p>The majority of tasks in the CKA will also be around creating Kubernetes resources, like it's tested in the CKAD. So preparing a bit for the CKAD can't hurt.</p>
  </li>
  <li>
    <p>Learn and Study the in-browser scenarios on <a href="https://killercoda.com/killer-shell-cka">[https://killercoda.com/killer-shell-cka]{.underline}</a> (and maybe for CKAD <a href="https://killercoda.com/killer-shell-ckad">[https://killercoda.com/killer-shell-ckad]{.underline}</a>)</p>
  </li>
  <li>
    <p>Imagine and create your own scenarios to solve</p>
  </li>
</ul>

<p> </p>

<p><strong>Components</strong></p>

<ul>
  <li>
    <p>Understanding Kubernetes components and being able to fix and investigate clusters: <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster">[https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster]{.underline}</a></p>
  </li>
  <li>
    <p>Know advanced scheduling: <a href="https://kubernetes.io/docs/concepts/scheduling/kube-scheduler">[https://kubernetes.io/docs/concepts/scheduling/kube-scheduler]{.underline}</a></p>
  </li>
  <li>
    <p>When you have to fix a component (like kubelet) in one cluster, just check how it's setup on another node in the same or even another cluster. You can copy config files over etc</p>
  </li>
  <li>
    <p>If you like you can look at <a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">[Kubernetes The Hard Way]{.underline}</a> once. But it's NOT necessary to do, the CKA is not that complex. But KTHW helps understanding the concepts</p>
  </li>
  <li>
    <p>You should install your own cluster using kubeadm (one controlplane, one worker) in a VM or using a cloud provider and investigate the components</p>
  </li>
  <li>
    <p>Know how to use Kubeadm to for example add nodes to a cluster</p>
  </li>
  <li>
    <p>Know how to create an Ingress resources</p>
  </li>
  <li>
    <p>Know how to snapshot/restore ETCD from another machine</p>
  </li>
</ul>

<p> </p>

<p> </p>

<p><strong>CKA Preparation</strong></p>

<p><strong>Read the Curriculum</strong></p>

<p><a href="https://github.com/cncf/curriculum">[https://github.com/cncf/curriculum]{.underline}</a></p>

<p><strong>Read the Handbook</strong></p>

<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/lf-handbook2">[https://docs.linuxfoundation.org/tc-docs/certification/lf-handbook2]{.underline}</a></p>

<p><strong>Read the important tips</strong></p>

<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad">[https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad]{.underline}</a></p>

<p><strong>Read the FAQ</strong></p>

<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad">[https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad]{.underline}</a></p>

<p> </p>

<p><strong>Kubernetes documentation</strong></p>

<p>Get familiar with the Kubernetes documentation and be able to use the search. Allowed links are:</p>

<ul>
  <li>
    <p><a href="https://kubernetes.io/docs">[https://kubernetes.io/docs]{.underline}</a></p>
  </li>
  <li>
    <p><a href="https://kubernetes.io/blog">[https://kubernetes.io/blog]{.underline}</a></p>
  </li>
  <li>
    <p><a href="https://helm.sh/docs">[https://helm.sh/docs]{.underline}</a></p>
  </li>
</ul>

<p><strong><em>NOTE:</em></strong> Verify the list <a href="https://docs.linuxfoundation.org/tc-docs/certification/certification-resources-allowed#certified-kubernetes-administrator-cka-and-certified-kubernetes-application-developer-ckad">[here]{.underline}</a></p>

<p> </p>

<p><strong>The Test Environment / Browser Terminal</strong></p>

<p>You'll be provided with a browser terminal which uses Ubuntu 20. The standard shells included with a minimal install of Ubuntu 20 will be available, including bash.</p>

<p><strong>Laggin</strong></p>

<p>There could be some lagging, definitely make sure you are using a good internet connection because your webcam and screen are uploading all the time.</p>

<p><strong>Kubectl autocompletion and commands</strong></p>

<p>Autocompletion is configured by default, as well as the k alias <a href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad">[source]{.underline}</a> and others:</p>

<p>kubectl with k alias and Bash autocompletion</p>

<p>yq and jqfor YAML/JSON processing</p>

<p>tmux for terminal multiplexing</p>

<p>curl and wget for testing web services</p>

<p>man and man pages for further documentation</p>

<p><strong>Copy &amp; Paste</strong></p>

<p>There could be issues copying text (like pod names) from the left task information into the terminal. Some suggested to "hard" hit or long hold Cmd/Ctrl+C a few times to take action. Apart from that copy and paste should just work like in normal terminals.</p>

<p><strong>Score</strong></p>

<p>There are 15-20 questions in the exam. Your results will be automatically checked according to the handbook. If you don't agree with the results you can request a review by contacting the Linux Foundation Support.</p>

<p><strong>Notepad &amp; Skipping Questions</strong></p>

<p>You have access to a simple notepad in the browser which can be used for storing any kind of plain text. It might makes sense to use this for saving skipped question numbers. This way it's possible to move some questions to the end.</p>

<p><strong>Contexts</strong></p>

<p>You'll receive access to various different clusters and resources in each. They provide you the exact command you need to run to connect to another cluster/context. But you should be comfortable working in different namespaces with kubectl.</p>

<p> </p>

<p><strong>PSI Bridge</strong></p>

<p>Starting with <a href="https://training.linuxfoundation.org/bridge-migration-2021">[PSI Bridge]{.underline}</a>:</p>

<ul>
  <li>
    <p>The exam will now be taken using the PSI Secure Browser, which can be downloaded using the newest versions of Microsoft Edge, Safari, Chrome, or Firefox</p>
  </li>
  <li>
    <p>Multiple monitors will no longer be permitted</p>
  </li>
  <li>
    <p>Use of personal bookmarks will no longer be permitted</p>
  </li>
</ul>

<p>The new ExamUI includes improved features such as:</p>

<ul>
  <li>
    <p>A remote desktop configured with the tools and software needed to complete the tasks</p>
  </li>
  <li>
    <p>A timer that displays the actual time remaining (in minutes) and provides an alert with 30, 15, or 5 minute remaining</p>
  </li>
  <li>
    <p>The content panel remains the same (presented on the Left Hand Side of the ExamUI)</p>
  </li>
</ul>

<p>Read more <a href="https://training.linuxfoundation.org/bridge-migration-2021">[here]{.underline}</a>.</p>

<p> </p>

<p><strong>Browser Terminal Setup</strong></p>

<p>It should be considered to spend ~1 minute in the beginning to setup your terminal. In the real exam the vast majority of questions will be done from the main terminal. For few you might need to ssh into another machine. Just be aware that configurations to your shell will not be transferred in this case.</p>

<p><strong>Minimal Setup</strong></p>

<p><strong>Alias</strong></p>

<p>The alias k for kubectl will already be configured together with autocompletion. In case not you can configure it using this <a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet">[link]{.underline}</a>.</p>

<p><strong>Vim</strong></p>

<p>The following settings will already be configured in your real exam environment in ~/.vimrc. But it can never hurt to be able to type these down:</p>

<p>set tabstop=2</p>

<p>set expandtab</p>

<p>set shiftwidth=2</p>

<p>The expandtab make sure to use spaces for tabs. Memorize these and just type them down. You can't have any written notes with commands on your desktop etc.</p>

<p><strong>Optional Setup</strong></p>

<p><strong>Fast dry-run output</strong></p>

<p>export do="--dry-run=client -o yaml"</p>

<p>This way you can just run k run pod1 --image=nginx $do. Short for "dry output", but use whatever name you like.</p>

<p><strong>Fast pod delete</strong></p>

<p>export now="--force --grace-period 0"</p>

<p>This way you can run k delete pod1 $now and don't have to wait for ~30 seconds termination time.</p>

<p><strong>Persist bash settings</strong></p>

<p>You can store aliases and other setup in ~/.bashrc if you're planning on using different shells or tmux.</p>

<p><strong>Alias Namespace</strong></p>

<p>In addition you could define an alias like:</p>

<p>alias kn='kubectl config set-context --current --namespace '</p>

<p>Which allows you to define the default namespace of the current context. Then once you switch a context or namespace you can just run:</p>

<p>kn default        # set default to default</p>

<p>kn my-namespace   # set default to my-namespace</p>

<p>But only do this if you used it before and are comfortable doing so. Else you need to specify the namespace for every call, which is also fine:</p>

<p>k -n my-namespace get all</p>

<p>k -n my-namespace get pod</p>

<p>...</p>

<p> </p>

<p><strong>Be fast</strong></p>

<p>Use the history command to reuse already entered commands or use even faster history search through <strong>Ctrl r </strong>.</p>

<p>If a command takes some time to execute, like sometimes kubectl delete pod x. You can put a task in the background using <strong>Ctrl z</strong> and pull it back into foreground running command fg.</p>

<p>You can delete <em>pods</em> fast with:</p>

<p>k delete pod x --grace-period 0 --force</p>

<p>k delete pod x $now # if export from above is configured</p>

<p> </p>

<p><strong>Vim</strong></p>

<p>Be great with vim.</p>

<p><strong>toggle vim line numbers</strong></p>

<p>When in vim you can press <strong>Esc</strong> and type :set number or :set nonumber followed by <strong>Enter</strong> to toggle line numbers. This can be useful when finding syntax errors based on line - but can be bad when wanting to mark&amp;copy by mouse. You can also just jump to a line number with <strong>Esc</strong> :22 + <strong>Enter</strong>.</p>

<p><strong>copy&amp;paste</strong></p>

<p>Get used to copy/paste/cut with vim:</p>

<p>Mark lines: Esc+V (then arrow keys)</p>

<p>Copy marked lines: y</p>

<p>Cut marked lines: d</p>

<p>Past lines: p or P</p>

<p><strong>Indent multiple lines</strong></p>

<p>To indent multiple lines press <strong>Esc</strong> and type :set shiftwidth=2. First mark multiple lines using Shift v and the up/down keys. Then to indent the marked lines press &gt; or &lt;. You can then press . to repeat the action.</p>

<p> </p>

<p><strong>Split terminal screen</strong></p>

<p>By default tmux is installed and can be used to split your one terminal into multiple. <strong>But</strong> just do this if you know your shit, because scrolling is different and copy&amp;pasting might be weird.</p>

<p><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux">[https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux]{.underline}</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[author: Vitalie Procopan date: 2024-06-09 09:35:00 changed: 2024-06-09 09:35:00 —]]></summary></entry><entry><title type="html">CKA killer.sh dump1</title><link href="http://localhost:4000/2024/02/27/CKA-1.html" rel="alternate" type="text/html" title="CKA killer.sh dump1" /><published>2024-02-27T00:00:00+02:00</published><updated>2024-02-27T00:00:00+02:00</updated><id>http://localhost:4000/2024/02/27/CKA-1</id><content type="html" xml:base="http://localhost:4000/2024/02/27/CKA-1.html"><![CDATA[<hr />
<p>author: Vitalie Procopan
date: 2024-06-09 09:25:00
changed: 2024-06-09 09:26:00
—</p>

<p><strong>CKA Simulator Kubernetes 1.29</strong></p>

<p><a href="https://killer.sh/">[https://killer.sh]{.underline}</a></p>

<p><strong>Pre Setup</strong></p>

<p>Once you've gained access to your terminal it might be wise to spend ~1 minute to setup your environment. You could set these:</p>

<p>alias k=kubectl                         # will already be pre-configured</p>

<p>export do="--dry-run=client -o yaml"    # k create deploy nginx --image=nginx $do</p>

<p>export now="--force --grace-period 0"   # k delete pod x $now</p>

<p><strong>Vim</strong></p>

<p>The following settings will already be configured in your real exam environment in ~/.vimrc. But it can never hurt to be able to type these down:</p>

<p>set tabstop=2</p>

<p>set expandtab</p>

<p>set shiftwidth=2</p>

<p>More setup suggestions are in the <strong>tips section</strong>.</p>

<p> </p>

<p> </p>

<p><strong>Question 1 | Contexts</strong></p>

<p> </p>

<p>You have access to multiple clusters from your main terminal through kubectl contexts. Write all those context names into /opt/course/1/contexts.</p>

<p>Next write a command to display the current context into /opt/course/1/context_default_kubectl.sh, the command should use kubectl.</p>

<p>Finally write a second command doing the same thing into /opt/course/1/context_default_no_kubectl.sh, but without the use of kubectl.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>Maybe the fastest way is just to run:</p>

<p>k config get-contexts # copy manually</p>

<p>k config get-contexts -o name &gt; /opt/course/1/contexts</p>

<p>Or using jsonpath:</p>

<p>k config view -o yaml # overview</p>

<p>k config view -o jsonpath="{.contexts[*].name}"</p>

<p>k config view -o jsonpath="{.contexts[*].name}" | tr " " "\n" # new lines</p>

<p>k config view -o jsonpath="{.contexts[*].name}" | tr " " "\n" &gt; /opt/course/1/contexts</p>

<p>The content should then look like:</p>

<p># /opt/course/1/contexts</p>

<p>k8s-c1-H</p>

<p>k8s-c2-AC</p>

<p>k8s-c3-CCC</p>

<p>Next create the first command:</p>

<p># /opt/course/1/context_default_kubectl.sh</p>

<p>kubectl config current-context</p>

<p>➜ sh /opt/course/1/context_default_kubectl.sh</p>

<p>k8s-c1-H</p>

<p>And the second one:</p>

<p># /opt/course/1/context_default_no_kubectl.sh</p>

<p>cat ~/.kube/config | grep current</p>

<p>➜ sh /opt/course/1/context_default_no_kubectl.sh</p>

<p>current-context: k8s-c1-H</p>

<p>In the real exam you might need to filter and find information from bigger lists of resources, hence knowing a little jsonpath and simple bash filtering will be helpful.</p>

<p>The second command could also be improved to:</p>

<p># /opt/course/1/context_default_no_kubectl.sh</p>

<p>cat ~/.kube/config | grep current | sed -e "s/current-context: //"</p>

<p> </p>

<p> </p>

<p><strong>Question 2 | Schedule Pod on Controlplane Nodes</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a single <em>Pod</em> of image httpd:2.4.41-alpine in <em>Namespace</em> default. The <em>Pod</em> should be named pod1 and the container should be named pod1-container. This <em>Pod</em> should <strong>only</strong> be scheduled on controlplane nodes. Do not add new labels to any nodes.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we find the controlplane node(s) and their taints:</p>

<p>k get node # find controlplane node</p>

<p>k describe node cluster1-controlplane1 | grep Taint -A1 # get controlplane node taints</p>

<p>k get node cluster1-controlplane1 --show-labels # get controlplane node labels</p>

<p> </p>

<p>Next we create the <em>Pod</em> template:</p>

<p># check the export on the very top of this document so we can use $do</p>

<p>k run pod1 --image=httpd:2.4.41-alpine $do &gt; 2.yaml</p>

<p>vim 2.yaml</p>

<p>Perform the necessary changes manually. Use the Kubernetes docs and search for example for tolerations and nodeSelector to find examples:</p>

<p># 2.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: pod1</p>

<p>name: pod1</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: httpd:2.4.41-alpine</p>

<p>  name: pod1-container                       # change</p>

<p>  resources: {}</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>tolerations:                                 # add</p>

<p>- effect: NoSchedule                         # add</p>

<p>  key: node-role.kubernetes.io/control-plane # add</p>

<p>nodeSelector:                                # add</p>

<p>  node-role.kubernetes.io/control-plane: ""  # add</p>

<p>status: {}</p>

<p>Important here to add the toleration for running on controlplane nodes, but also the nodeSelector to make sure it only runs on controlplane nodes. If we only specify a toleration the <em>Pod</em> can be scheduled on controlplane or worker nodes.</p>

<p>Now we create it:</p>

<p>k -f 2.yaml create</p>

<p>Let's check if the pod is scheduled:</p>

<p>➜ k get pod pod1 -o wide</p>

<p>NAME   READY   STATUS   RESTARTS   ...   NODE                     NOMINATED NODE</p>

<p>pod1   1/1     Running   0         ...   cluster1-controlplane1   &lt;none&gt;        </p>

<p> </p>

<p> </p>

<p><strong>Question 3 | Scale down StatefulSet</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There are two <em>Pods</em> named o3db-* in <em>Namespace</em> project-c13. C13 management asked you to scale the <em>Pods</em> down to one replica to save resources.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>If we check the <em>Pods</em> we see two replicas:</p>

<p>➜ k -n project-c13 get pod | grep o3db</p>

<p>o3db-0                                 1/1     Running   0         52s</p>

<p>o3db-1                                 1/1     Running   0         42s</p>

<p>From their name it looks like these are managed by a <em>StatefulSet</em>. But if we're not sure we could also check for the most common resources which manage <em>Pods</em>:</p>

<p>➜ k -n project-c13 get deploy,ds,sts | grep o3db</p>

<p>statefulset.apps/o3db   2/2     2m56s</p>

<p>Confirmed, we have to work with a <em>StatefulSet</em>. To find this out we could also look at the <em>Pod</em> labels:</p>

<p>➜ k -n project-c13 get pod --show-labels | grep o3db</p>

<p>o3db-0                                 1/1     Running   0         3m29s   app=nginx,controller-revision-hash=o3db-5fbd4bb9cc,statefulset.kubernetes.io/pod-name=o3db-0</p>

<p>o3db-1                                 1/1     Running   0         3m19s   app=nginx,controller-revision-hash=o3db-5fbd4bb9cc,statefulset.kubernetes.io/pod-name=o3db-1</p>

<p>To fulfil the task we simply run:</p>

<p>➜ k -n project-c13 scale sts o3db --replicas 1</p>

<p>statefulset.apps/o3db scaled</p>

<p>➜ k -n project-c13 get sts o3db</p>

<p>NAME   READY   AGE</p>

<p>o3db   1/1     4m39s</p>

<p>C13 Mangement is happy again.</p>

<p> </p>

<p> </p>

<p><strong>Question 4 | Pod Ready if Service is reachable</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Do the following in <em>Namespace</em> default. Create a single <em>Pod</em> named ready-if-service-ready of image nginx:1.16.1-alpine. Configure a LivenessProbe which simply executes command true. Also configure a ReadinessProbe which does check if the url http://service-am-i-ready:80 is reachable, you can use wget -T2 -O- http://service-am-i-ready:80 for this. Start the <em>Pod</em> and confirm it isn't ready because of the ReadinessProbe.</p>

<p>Create a second <em>Pod</em> named am-i-ready of image nginx:1.16.1-alpine with label id: cross-server-ready. The already existing <em>Service</em> service-am-i-ready should now have that second <em>Pod</em> as endpoint.</p>

<p>Now the first <em>Pod</em> should be in ready state, confirm that.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>It's a bit of an anti-pattern for one <em>Pod</em> to check another <em>Pod</em> for being ready using probes, hence the normally available readinessProbe.httpGet doesn't work for absolute remote urls. Still the workaround requested in this task should show how probes and <em>Pod</em>&lt;-&gt;<em>Service</em> communication works.</p>

<p>First we create the first <em>Pod</em>:</p>

<p>k run ready-if-service-ready --image=nginx:1.16.1-alpine $do &gt; 4_pod1.yaml</p>

<p>vim 4_pod1.yaml</p>

<p>Next perform the necessary additions manually:</p>

<p># 4_pod1.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: ready-if-service-ready</p>

<p>name: ready-if-service-ready</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.16.1-alpine</p>

<p>  name: ready-if-service-ready</p>

<p>  resources: {}</p>

<p>  livenessProbe:                                      # add from here</p>

<p>    exec:</p>

<p>      command:</p>

<p>      - 'true'</p>

<p>  readinessProbe:</p>

<p>    exec:</p>

<p>      command:</p>

<p>      - sh</p>

<p>      - -c</p>

<p>      - 'wget -T2 -O- http://service-am-i-ready:80'   # to here</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p>Then create the <em>Pod</em>:</p>

<p>k -f 4_pod1.yaml create</p>

<p>And confirm it's in a non-ready state:</p>

<p>➜ k get pod ready-if-service-ready</p>

<p>NAME                     READY   STATUS   RESTARTS   AGE</p>

<p>ready-if-service-ready   0/1     Running   0         7s</p>

<p>We can also check the reason for this using describe:</p>

<p>➜ k describe pod ready-if-service-ready</p>

<p>...</p>

<p>Warning Unhealthy 18s   kubelet, cluster1-node1 Readiness probe failed: Connecting to service-am-i-ready:80 (10.109.194.234:80)</p>

<p>wget: download timed out</p>

<p>Now we create the second <em>Pod</em>:</p>

<p>k run am-i-ready --image=nginx:1.16.1-alpine --labels="id=cross-server-ready"</p>

<p>The already existing <em>Service</em> service-am-i-ready should now have an <em>Endpoint</em>:</p>

<p>k describe svc service-am-i-ready</p>

<p>k get ep # also possible</p>

<p>Which will result in our first <em>Pod</em> being ready, just give it a minute for the Readiness probe to check again:</p>

<p>➜ k get pod ready-if-service-ready</p>

<p>NAME                     READY   STATUS   RESTARTS   AGE</p>

<p>ready-if-service-ready   1/1     Running   0         53s</p>

<p>Look at these <em>Pods</em> coworking together!</p>

<p> </p>

<p> </p>

<p><strong>Question 5 | Kubectl sorting</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There are various <em>Pods</em> in all namespaces. Write a command into /opt/course/5/find_pods.sh which lists all <em>Pods</em> sorted by their AGE (metadata.creationTimestamp).</p>

<p>Write a second command into /opt/course/5/find_pods_uid.sh which lists all <em>Pods</em> sorted by field metadata.uid. Use kubectl sorting for both commands.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>A good resources here (and for many other things) is the kubectl-cheat-sheet. You can reach it fast when searching for "cheat sheet" in the Kubernetes docs.</p>

<p># /opt/course/5/find_pods.sh</p>

<p>kubectl get pod -A --sort-by=.metadata.creationTimestamp</p>

<p>And to execute:</p>

<p>➜ sh /opt/course/5/find_pods.sh</p>

<p>NAMESPACE         NAME                                             ...         AGE</p>

<p>kube-system       kube-scheduler-cluster1-controlplane1           ...         63m</p>

<p>kube-system       etcd-cluster1-controlplane1                     ...         63m</p>

<p>kube-system       kube-apiserver-cluster1-controlplane1           ...         63m</p>

<p>kube-system       kube-controller-manager-cluster1-controlplane1   ...         63m</p>

<p>...</p>

<p>For the second command:</p>

<p># /opt/course/5/find_pods_uid.sh</p>

<p>kubectl get pod -A --sort-by=.metadata.uid</p>

<p>And to execute:</p>

<p>➜ sh /opt/course/5/find_pods_uid.sh</p>

<p>NAMESPACE         NAME                                     ...         AGE</p>

<p>kube-system       coredns-5644d7b6d9-vwm7g                 ...         68m</p>

<p>project-c13       c13-3cc-runner-heavy-5486d76dd4-ddvlt     ...         63m</p>

<p>project-hamster   web-hamster-shop-849966f479-278vp         ...         63m</p>

<p>project-c13       c13-3cc-web-646b6c8756-qsg4b             ...         63m</p>

<p> </p>

<p> </p>

<p><strong>Question 6 | Storage, PV, PVC, Pod volume</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a new <em>PersistentVolume</em> named safari-pv. It should have a capacity of <em>2Gi</em>, accessMode <em>ReadWriteOnce</em>, hostPath /Volumes/Data and no storageClassName defined.</p>

<p>Next create a new <em>PersistentVolumeClaim</em> in <em>Namespace</em> project-tiger named safari-pvc . It should request <em>2Gi</em> storage, accessMode <em>ReadWriteOnce</em> and should not define a storageClassName. The <em>PVC</em> should bound to the <em>PV</em> correctly.</p>

<p>Finally create a new <em>Deployment</em> safari in <em>Namespace</em> project-tiger which mounts that volume at /tmp/safari-data. The <em>Pods</em> of that <em>Deployment</em> should be of image httpd:2.4.41-alpine.</p>

<p> </p>

<p><strong>Answer</strong></p>

<p>vim 6_pv.yaml</p>

<p>Find an example from <a href="https://kubernetes.io/docs">[https://kubernetes.io/docs]{.underline}</a> and alter it:</p>

<p># 6_pv.yaml</p>

<p>kind: PersistentVolume</p>

<p>apiVersion: v1</p>

<p>metadata:</p>

<p>name: safari-pv</p>

<p>spec:</p>

<p>capacity:</p>

<p>storage: 2Gi</p>

<p>accessModes:</p>

<p>- ReadWriteOnce</p>

<p>hostPath:</p>

<p>path: "/Volumes/Data"</p>

<p>Then create it:</p>

<p>k -f 6_pv.yaml create</p>

<p>Next the <em>PersistentVolumeClaim</em>:</p>

<p>vim 6_pvc.yaml</p>

<p>Find an example from <a href="https://kubernetes.io/docs">[https://kubernetes.io/docs]{.underline}</a> and alter it:</p>

<p># 6_pvc.yaml</p>

<p>kind: PersistentVolumeClaim</p>

<p>apiVersion: v1</p>

<p>metadata:</p>

<p>name: safari-pvc</p>

<p>namespace: project-tiger</p>

<p>spec:</p>

<p>accessModes:</p>

<p>  - ReadWriteOnce</p>

<p>resources:</p>

<p>  requests:</p>

<p>    storage: 2Gi</p>

<p>Then create:</p>

<p>k -f 6_pvc.yaml create</p>

<p>And check that both have the status Bound:</p>

<p>➜ k -n project-tiger get pv,pvc</p>

<p>NAME                         CAPACITY ... STATUS   CLAIM                   ...</p>

<p>persistentvolume/safari-pv   2Gi       ... Bound   project-tiger/safari-pvc ...</p>

<p>NAME                               STATUS   VOLUME     CAPACITY ...</p>

<p>persistentvolumeclaim/safari-pvc   Bound   safari-pv   2Gi     ...</p>

<p>Next we create a <em>Deployment</em> and mount that volume:</p>

<p>k -n project-tiger create deploy safari \</p>

<p>--image=httpd:2.4.41-alpine $do &gt; 6_dep.yaml</p>

<p>vim 6_dep.yaml</p>

<p>Alter the yaml to mount the volume:</p>

<p># 6_dep.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: Deployment</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  app: safari</p>

<p>name: safari</p>

<p>namespace: project-tiger</p>

<p>spec:</p>

<p>replicas: 1</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    app: safari</p>

<p>strategy: {}</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      app: safari</p>

<p>  spec:</p>

<p>    volumes:      # add</p>

<p>    - name: data      # add</p>

<p>      persistentVolumeClaim:      # add</p>

<p>        claimName: safari-pvc                     # add</p>

<p>    containers:</p>

<p>    - image: httpd:2.4.41-alpine</p>

<p>      name: container</p>

<p>      volumeMounts:      # add</p>

<p>      - name: data      # add</p>

<p>        mountPath: /tmp/safari-data      # add</p>

<p>k -f 6_dep.yaml create</p>

<p>We can confirm it's mounting correctly:</p>

<p>➜ k -n project-tiger describe pod safari-5cbf46d6d-mjhsb | grep -A2 Mounts:  </p>

<p>  Mounts:</p>

<p>    /tmp/safari-data from data (rw) # there it is</p>

<p>    /var/run/secrets/kubernetes.io/serviceaccount from default-token-n2sjj (ro)</p>

<p> </p>

<p> </p>

<p><strong>Question 7 | Node and Pod Resource Usage</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>The metrics-server has been installed in the cluster. Your college would like to know the kubectl commands to:</p>

<ol>
  <li>
    <p>show <em>Nodes</em> resource usage</p>
  </li>
  <li>
    <p>show <em>Pods</em> and their containers resource usage</p>
  </li>
</ol>

<p>Please write the commands into /opt/course/7/node.sh and /opt/course/7/pod.sh.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>The command we need to use here is top:</p>

<p>➜ k top -h</p>

<p>Display Resource (CPU/Memory/Storage) usage.</p>

<p>The top command allows you to see the resource consumption for nodes or pods.</p>

<p>This command requires Metrics Server to be correctly configured and working on the server.</p>

<p>Available Commands:</p>

<p>node       Display Resource (CPU/Memory/Storage) usage of nodes</p>

<p>pod         Display Resource (CPU/Memory/Storage) usage of pods</p>

<p>We see that the metrics server provides information about resource usage:</p>

<p>➜ k top node</p>

<p>NAME               CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%  </p>

<p>cluster1-controlplane1   178m         8%     1091Mi         57%      </p>

<p>cluster1-node1   66m         6%     834Mi           44%      </p>

<p>cluster1-node2   91m         9%     791Mi           41%</p>

<p>We create the first file:</p>

<p># /opt/course/7/node.sh</p>

<p>kubectl top node</p>

<p>For the second file we might need to check the docs again:</p>

<p>➜ k top pod -h</p>

<p>Display Resource (CPU/Memory/Storage) usage of pods.</p>

<p>...</p>

<p>Namespace in current context is ignored even if specified with --namespace.</p>

<p>    --containers=false: If present, print usage of containers within a pod.</p>

<p>    --no-headers=false: If present, print output without headers.</p>

<p>...</p>

<p>With this we can finish this task:</p>

<p># /opt/course/7/pod.sh</p>

<p>kubectl top pod --containers=true</p>

<p> </p>

<p> </p>

<p><strong>Question 8 | Get Controlplane Information</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Ssh into the controlplane node with ssh cluster1-controlplane1. Check how the controlplane components kubelet, kube-apiserver, kube-scheduler, kube-controller-manager and etcd are started/installed on the controlplane node. Also find out the name of the DNS application and how it's started/installed on the controlplane node.</p>

<p>Write your findings into file /opt/course/8/controlplane-components.txt. The file should be structured like:</p>

<p># /opt/course/8/controlplane-components.txt</p>

<p>kubelet: [TYPE]</p>

<p>kube-apiserver: [TYPE]</p>

<p>kube-scheduler: [TYPE]</p>

<p>kube-controller-manager: [TYPE]</p>

<p>etcd: [TYPE]</p>

<p>dns: [TYPE] [NAME]</p>

<p>Choices of [TYPE] are: not-installed, process, static-pod, pod</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>We could start by finding processes of the requested components, especially the kubelet at first:</p>

<p>➜ ssh cluster1-controlplane1</p>

<p>root@cluster1-controlplane1:~# ps aux | grep kubelet # shows kubelet process</p>

<p>We can see which components are controlled via systemd looking at /usr/lib/systemd directory:</p>

<p>➜ root@cluster1-controlplane1:~# find /usr/lib/systemd | grep kube</p>

<p>/usr/lib/systemd/system/kubelet.service</p>

<p>/usr/lib/systemd/system/kubelet.service.d</p>

<p>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</p>

<p>➜ root@cluster1-controlplane1:~# find /usr/lib/systemd | grep etcd</p>

<p>This shows kubelet is controlled via systemd, but no other service named kube nor etcd. It seems that this cluster has been setup using kubeadm, so we check in the default manifests directory:</p>

<p>➜ root@cluster1-controlplane1:~# find /etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p>/etc/kubernetes/manifests/etcd.yaml</p>

<p>/etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p>/etc/kubernetes/manifests/kube-scheduler.yaml</p>

<p>(The kubelet could also have a different manifests directory specified via parameter --pod-manifest-path in it's systemd startup config)</p>

<p>This means the main 4 controlplane services are setup as static <em>Pods</em>. Actually, let's check all <em>Pods</em> running on in the kube-system <em>Namespace</em> on the controlplane node:</p>

<p>➜ root@cluster1-controlplane1:~# kubectl -n kube-system get pod -o wide | grep controlplane1</p>

<p>coredns-5644d7b6d9-c4f68                           1/1     Running           ...   cluster1-controlplane1</p>

<p>coredns-5644d7b6d9-t84sc                           1/1     Running           ...   cluster1-controlplane1</p>

<p>etcd-cluster1-controlplane1                         1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-apiserver-cluster1-controlplane1               1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-controller-manager-cluster1-controlplane1     1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-proxy-q955p                                   1/1     Running           ...   cluster1-controlplane1</p>

<p>kube-scheduler-cluster1-controlplane1               1/1     Running           ...   cluster1-controlplane1</p>

<p>weave-net-mwj47                                     2/2     Running           ...   cluster1-controlplane1</p>

<p>There we see the 5 static pods, with -cluster1-controlplane1 as suffix.</p>

<p>We also see that the dns application seems to be coredns, but how is it controlled?</p>

<p>➜ root@cluster1-controlplane1$ kubectl -n kube-system get ds</p>

<p>NAME         DESIRED   CURRENT   ...   NODE SELECTOR           AGE</p>

<p>kube-proxy   3         3         ...   kubernetes.io/os=linux   155m</p>

<p>weave-net   3         3         ...   &lt;none&gt;                   155m</p>

<p>➜ root@cluster1-controlplane1$ kubectl -n kube-system get deploy</p>

<p>NAME     READY   UP-TO-DATE   AVAILABLE   AGE</p>

<p>coredns   2/2     2           2           155m</p>

<p>Seems like coredns is controlled via a <em>Deployment</em>. We combine our findings in the requested file:</p>

<p># /opt/course/8/controlplane-components.txt</p>

<p>kubelet: process</p>

<p>kube-apiserver: static-pod</p>

<p>kube-scheduler: static-pod</p>

<p>kube-controller-manager: static-pod</p>

<p>etcd: static-pod</p>

<p>dns: pod coredns</p>

<p>You should be comfortable investigating a running cluster, know different methods on how a cluster and its services can be setup and be able to troubleshoot and find error sources.</p>

<p> </p>

<p> </p>

<p><strong>Question 9 | Kill Scheduler, Manual Scheduling</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Ssh into the controlplane node with ssh cluster2-controlplane1. <strong>Temporarily</strong> stop the kube-scheduler, this means in a way that you can start it again afterwards.</p>

<p>Create a single <em>Pod</em> named manual-schedule of image httpd:2.4-alpine, confirm it's created but not scheduled on any node.</p>

<p>Now you're the scheduler and have all its power, manually schedule that <em>Pod</em> on node cluster2-controlplane1. Make sure it's running.</p>

<p>Start the kube-scheduler again and confirm it's running correctly by creating a second <em>Pod</em> named manual-schedule2 of image httpd:2.4-alpine and check if it's running on cluster2-node1.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Stop the Scheduler</strong></p>

<p>First we find the controlplane node:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster2-controlplane1   Ready   control-plane   26h   v1.29.0</p>

<p>cluster2-node1           Ready   &lt;none&gt;         26h   v1.29.0</p>

<p>Then we connect and check if the scheduler is running:</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep schedule</p>

<p>kube-scheduler-cluster2-controlplane1           1/1     Running   0         6s</p>

<p>Kill the Scheduler (temporarily):</p>

<p>➜ root@cluster2-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>➜ root@cluster2-controlplane1:~# mv kube-scheduler.yaml ..</p>

<p>And it should be stopped:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep schedule</p>

<p>➜ root@cluster2-controlplane1:~#</p>

<p> </p>

<p><strong>Create a <em>Pod</em></strong></p>

<p>Now we create the <em>Pod</em>:</p>

<p>k run manual-schedule --image=httpd:2.4-alpine</p>

<p>And confirm it has no node assigned:</p>

<p>➜ k get pod manual-schedule -o wide</p>

<p>NAME             READY   STATUS   ...   NODE     NOMINATED NODE</p>

<p>manual-schedule   0/1     Pending   ...   &lt;none&gt;   &lt;none&gt;        </p>

<p> </p>

<p><strong>Manually schedule the <em>Pod</em></strong></p>

<p>Let's play the scheduler now:</p>

<p>k get pod manual-schedule -o yaml &gt; 9.yaml</p>

<p># 9.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: "2020-09-04T15:51:02Z"</p>

<p>labels:</p>

<p>  run: manual-schedule</p>

<p>managedFields:</p>

<p>...</p>

<p>  manager: kubectl-run</p>

<p>  operation: Update</p>

<p>  time: "2020-09-04T15:51:02Z"</p>

<p>name: manual-schedule</p>

<p>namespace: default</p>

<p>resourceVersion: "3515"</p>

<p>selfLink: /api/v1/namespaces/default/pods/manual-schedule</p>

<p>uid: 8e9d2532-4779-4e63-b5af-feb82c74a935</p>

<p>spec:</p>

<p>nodeName: cluster2-controlplane1 # add the controlplane node name</p>

<p>containers:</p>

<p>- image: httpd:2.4-alpine</p>

<p>  imagePullPolicy: IfNotPresent</p>

<p>  name: manual-schedule</p>

<p>  resources: {}</p>

<p>  terminationMessagePath: /dev/termination-log</p>

<p>  terminationMessagePolicy: File</p>

<p>  volumeMounts:</p>

<p>  - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</p>

<p>    name: default-token-nxnc7</p>

<p>    readOnly: true</p>

<p>dnsPolicy: ClusterFirst</p>

<p>...</p>

<p>The only thing a scheduler does, is that it sets the nodeName for a <em>Pod</em> declaration. How it finds the correct node to schedule on, that's a very much complicated matter and takes many variables into account.</p>

<p>As we cannot kubectl apply or kubectl edit , in this case we need to delete and create or replace:</p>

<p>k -f 9.yaml replace --force</p>

<p>How does it look?</p>

<p>➜ k get pod manual-schedule -o wide</p>

<p>NAME             READY   STATUS   ...   NODE            </p>

<p>manual-schedule   1/1     Running   ...   cluster2-controlplane1</p>

<p>It looks like our <em>Pod</em> is running on the controlplane now as requested, although no tolerations were specified. Only the scheduler takes tains/tolerations/affinity into account when finding the correct node name. That's why it's still possible to assign <em>Pods</em> manually directly to a controlplane node and skip the scheduler.</p>

<p> </p>

<p><strong>Start the scheduler again</strong></p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>➜ root@cluster2-controlplane1:~# mv ../kube-scheduler.yaml .</p>

<p>Checks it's running:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep schedule</p>

<p>kube-scheduler-cluster2-controlplane1           1/1     Running   0         16s</p>

<p>Schedule a second test <em>Pod</em>:</p>

<p>k run manual-schedule2 --image=httpd:2.4-alpine</p>

<p>➜ k get pod -o wide | grep schedule</p>

<p>manual-schedule   1/1     Running   ...   cluster2-controlplane1</p>

<p>manual-schedule2   1/1     Running   ...   cluster2-node1</p>

<p>Back to normal.</p>

<p> </p>

<p> </p>

<p><strong>Question 10 | RBAC ServiceAccount Role RoleBinding</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a new <em>ServiceAccount</em> processor in <em>Namespace</em> project-hamster. Create a <em>Role</em> and <em>RoleBinding</em>, both named processor as well. These should allow the new <em>SA</em> to only create <em>Secrets</em> and <em>ConfigMaps</em> in that <em>Namespace</em>.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Let's talk a little about RBAC resources</strong></p>

<p>A <em>ClusterRole</em>|<em>Role</em> defines a set of permissions and <strong>where it is available</strong>, in the whole cluster or just a single <em>Namespace</em>.</p>

<p>A <em>ClusterRoleBinding</em>|<em>RoleBinding</em> connects a set of permissions with an account and defines <strong>where it is applied</strong>, in the whole cluster or just a single <em>Namespace</em>.</p>

<p>Because of this there are 4 different RBAC combinations and 3 valid ones:</p>

<ol>
  <li>
    <p><em>Role</em> + <em>RoleBinding</em> (available in single <em>Namespace</em>, applied in single <em>Namespace</em>)</p>
  </li>
  <li>
    <p><em>ClusterRole</em> + <em>ClusterRoleBinding</em> (available cluster-wide, applied cluster-wide)</p>
  </li>
  <li>
    <p><em>ClusterRole</em> + <em>RoleBinding</em> (available cluster-wide, applied in single <em>Namespace</em>)</p>
  </li>
  <li>
    <p><em>Role</em> + <em>ClusterRoleBinding</em> (<strong>NOT POSSIBLE:</strong> available in single <em>Namespace</em>, applied cluster-wide)</p>
  </li>
</ol>

<p><strong>To the solution</strong></p>

<p>We first create the <em>ServiceAccount</em>:</p>

<p>➜ k -n project-hamster create sa processor</p>

<p>serviceaccount/processor created</p>

<p>Then for the <em>Role</em>:</p>

<p>k -n project-hamster create role -h # examples</p>

<p>So we execute:</p>

<p>k -n project-hamster create role processor \</p>

<p>--verb=create \</p>

<p>--resource=secret \</p>

<p>--resource=configmap</p>

<p>Which will create a <em>Role</em> like:</p>

<p># kubectl -n project-hamster create role processor --verb=create --resource=secret --resource=configmap</p>

<p>apiVersion: rbac.authorization.k8s.io/v1</p>

<p>kind: Role</p>

<p>metadata:</p>

<p>name: processor</p>

<p>namespace: project-hamster</p>

<p>rules:</p>

<p>- apiGroups:</p>

<p>- ""</p>

<p>resources:</p>

<p>- secrets</p>

<p>- configmaps</p>

<p>verbs:</p>

<p>- create</p>

<p>Now we bind the <em>Role</em> to the <em>ServiceAccount</em>:</p>

<p>k -n project-hamster create rolebinding -h # examples</p>

<p>So we create it:</p>

<p>k -n project-hamster create rolebinding processor \</p>

<p>--role processor \</p>

<p>--serviceaccount project-hamster:processor</p>

<p>This will create a <em>RoleBinding</em> like:</p>

<p># kubectl -n project-hamster create rolebinding processor --role processor --serviceaccount project-hamster:processor</p>

<p>apiVersion: rbac.authorization.k8s.io/v1</p>

<p>kind: RoleBinding</p>

<p>metadata:</p>

<p>name: processor</p>

<p>namespace: project-hamster</p>

<p>roleRef:</p>

<p>apiGroup: rbac.authorization.k8s.io</p>

<p>kind: Role</p>

<p>name: processor</p>

<p>subjects:</p>

<p>- kind: ServiceAccount</p>

<p>name: processor</p>

<p>namespace: project-hamster</p>

<p>To test our RBAC setup we can use kubectl auth can-i:</p>

<p>k auth can-i -h # examples</p>

<p>Like this:</p>

<p>➜ k -n project-hamster auth can-i create secret \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>yes</p>

<p>➜ k -n project-hamster auth can-i create configmap \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>yes</p>

<p>➜ k -n project-hamster auth can-i create pod \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>no</p>

<p>➜ k -n project-hamster auth can-i delete secret \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>no</p>

<p>➜ k -n project-hamster auth can-i get configmap \</p>

<p>--as system:serviceaccount:project-hamster:processor</p>

<p>no</p>

<p>Done.</p>

<p> </p>

<p> </p>

<p><strong>Question 11 | DaemonSet on all Nodes</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Use <em>Namespace</em> project-tiger for the following. Create a <em>DaemonSet</em> named ds-important with image httpd:2.4-alpine and labels id=ds-important and uuid=18426a0b-5f59-4e10-923f-c0e078e82462. The <em>Pods</em> it creates should request 10 millicore cpu and 10 mebibyte memory. The <em>Pods</em> of that <em>DaemonSet</em> should run on all nodes, also controlplanes.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>As of now we aren't able to create a <em>DaemonSet</em> directly using kubectl, so we create a <em>Deployment</em> and just change it up:</p>

<p>k -n project-tiger create deployment --image=httpd:2.4-alpine ds-important $do &gt; 11.yaml</p>

<p>vim 11.yaml</p>

<p>(Sure you could also search for a <em>DaemonSet</em> example yaml in the Kubernetes docs and alter it.)</p>

<p> </p>

<p>Then we adjust the yaml to:</p>

<p># 11.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: DaemonSet # change from Deployment to Daemonset</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:                                           # add</p>

<p>  id: ds-important                                # add</p>

<p>  uuid: 18426a0b-5f59-4e10-923f-c0e078e82462 # add</p>

<p>name: ds-important</p>

<p>namespace: project-tiger # important</p>

<p>spec:</p>

<p> #replicas: 1 # remove</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    id: ds-important # add</p>

<p>    uuid: 18426a0b-5f59-4e10-923f-c0e078e82462 # add</p>

<p> #strategy: {} # remove</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      id: ds-important # add</p>

<p>      uuid: 18426a0b-5f59-4e10-923f-c0e078e82462 # add</p>

<p>  spec:</p>

<p>    containers:</p>

<p>    - image: httpd:2.4-alpine</p>

<p>      name: ds-important</p>

<p>      resources:</p>

<p>        requests: # add</p>

<p>          cpu: 10m  # add</p>

<p>          memory: 10Mi  # add</p>

<p>    tolerations:                           # add</p>

<p>    - effect: NoSchedule                   # add</p>

<p>      key: node-role.kubernetes.io/control-plane  # add</p>

<p>#status: {} # remove</p>

<p>It was requested that the <em>DaemonSet</em> runs on all nodes, so we need to specify the toleration for this.</p>

<p>Let's confirm:</p>

<p>k -f 11.yaml create</p>

<p>➜ k -n project-tiger get ds</p>

<p>NAME           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</p>

<p>ds-important   3         3         3       3           3           &lt;none&gt;         8s</p>

<p>➜ k -n project-tiger get pod -l id=ds-important -o wide</p>

<p>NAME READY STATUS NODE</p>

<p>ds-important-6pvgm       1/1     Running   ...   cluster1-node1</p>

<p>ds-important-lh5ts       1/1     Running   ...   cluster1-controlplane1</p>

<p>ds-important-qhjcq       1/1     Running   ...   cluster1-node2</p>

<p> </p>

<p> </p>

<p><strong>Question 12 | Deployment on all Nodes</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Use <em>Namespace</em> project-tiger for the following. Create a <em>Deployment</em> named deploy-important with label id=very-important (the Pods should also have this label) and 3 replicas. It should contain two containers, the first named container1 with image nginx:1.17.6-alpine and the second one named container2 with image google/pause.</p>

<p>There should be only ever <strong>one</strong> <em>Pod</em> of that <em>Deployment</em> running on <strong>one</strong> worker node. We have two worker nodes: cluster1-node1 and cluster1-node2. Because the <em>Deployment</em> has three replicas the result should be that on both nodes <strong>one</strong> <em>Pod</em> is running. The third <em>Pod</em> won't be scheduled, unless a new worker node will be added. Use topologyKey: kubernetes.io/hostname for this.</p>

<p>In a way we kind of simulate the behaviour of a <em>DaemonSet</em> here, but using a <em>Deployment</em> and a fixed number of replicas.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>There are two possible ways, one using podAntiAffinity and one using topologySpreadConstraint.</p>

<p> </p>

<p><strong>PodAntiAffinity</strong></p>

<p>The idea here is that we create a "Inter-pod anti-affinity" which allows us to say a <em>Pod</em> should only be scheduled on a node where another <em>Pod</em> of a specific label (here the same label) is not already running.</p>

<p>Let's begin by creating the <em>Deployment</em> template:</p>

<p>k -n project-tiger create deployment \</p>

<p>--image=nginx:1.17.6-alpine deploy-important $do &gt; 12.yaml</p>

<p>vim 12.yaml</p>

<p>Then change the yaml to:</p>

<p># 12.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: Deployment</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  id: very-important # change</p>

<p>name: deploy-important</p>

<p>namespace: project-tiger # important</p>

<p>spec:</p>

<p>replicas: 3 # change</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    id: very-important # change</p>

<p>strategy: {}</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      id: very-important # change</p>

<p>  spec:</p>

<p>    containers:</p>

<p>    - image: nginx:1.17.6-alpine</p>

<p>      name: container1 # change</p>

<p>      resources: {}</p>

<p>    - image: google/pause             # add</p>

<p>      name: container2 # add</p>

<p>    affinity:  # add</p>

<p>      podAntiAffinity:  # add</p>

<p>        requiredDuringSchedulingIgnoredDuringExecution: # add</p>

<p>        - labelSelector: # add</p>

<p>            matchExpressions: # add</p>

<p>            - key: id # add</p>

<p>              operator: In  # add</p>

<p>              values:  # add</p>

<p>              - very-important  # add</p>

<p>          topologyKey: kubernetes.io/hostname  # add</p>

<p>status: {}</p>

<p>Specify a topologyKey, which is a pre-populated Kubernetes label, you can find this by describing a node.</p>

<p> </p>

<p><strong>TopologySpreadConstraints</strong></p>

<p>We can achieve the same with topologySpreadConstraints. Best to try out and play with both.</p>

<p># 12.yaml</p>

<p>apiVersion: apps/v1</p>

<p>kind: Deployment</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  id: very-important # change</p>

<p>name: deploy-important</p>

<p>namespace: project-tiger # important</p>

<p>spec:</p>

<p>replicas: 3 # change</p>

<p>selector:</p>

<p>  matchLabels:</p>

<p>    id: very-important # change</p>

<p>strategy: {}</p>

<p>template:</p>

<p>  metadata:</p>

<p>    creationTimestamp: null</p>

<p>    labels:</p>

<p>      id: very-important # change</p>

<p>  spec:</p>

<p>    containers:</p>

<p>    - image: nginx:1.17.6-alpine</p>

<p>      name: container1 # change</p>

<p>      resources: {}</p>

<p>    - image: google/pause             # add</p>

<p>      name: container2 # add</p>

<p>    topologySpreadConstraints:                 # add</p>

<p>    - maxSkew: 1                               # add</p>

<p>      topologyKey: kubernetes.io/hostname      # add</p>

<p>      whenUnsatisfiable: DoNotSchedule         # add</p>

<p>      labelSelector:                           # add</p>

<p>        matchLabels:                           # add</p>

<p>          id: very-important                   # add</p>

<p>status: {}</p>

<p> </p>

<p><strong>Apply and Run</strong></p>

<p>Let's run it:</p>

<p>k -f 12.yaml create</p>

<p>Then we check the <em>Deployment</em> status where it shows 2/3 ready count:</p>

<p>➜ k -n project-tiger get deploy -l id=very-important</p>

<p>NAME               READY   UP-TO-DATE   AVAILABLE   AGE</p>

<p>deploy-important   2/3     3           2           2m35s</p>

<p>And running the following we see one <em>Pod</em> on each worker node and one not scheduled.</p>

<p>➜ k -n project-tiger get pod -o wide -l id=very-important</p>

<p>NAME                               READY   STATUS   ...   NODE            </p>

<p>deploy-important-58db9db6fc-9ljpw   2/2     Running   ...   cluster1-node1</p>

<p>deploy-important-58db9db6fc-lnxdb   0/2     Pending   ...   &lt;none&gt;          </p>

<p>deploy-important-58db9db6fc-p2rz8   2/2     Running   ...   cluster1-node2</p>

<p>If we kubectl describe the <em>Pod</em> deploy-important-58db9db6fc-lnxdb it will show us the reason for not scheduling is our implemented podAntiAffinity ruling:</p>

<p>Warning FailedScheduling 63s (x3 over 65s) default-scheduler 0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/control-plane: }, that the pod didn't tolerate, 2 node(s) didn't match pod affinity/anti-affinity, 2 node(s) didn't satisfy existing pods anti-affinity rules.</p>

<p>Or our topologySpreadConstraints:</p>

<p>Warning FailedScheduling 16s   default-scheduler 0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/control-plane: }, that the pod didn't tolerate, 2 node(s) didn't match pod topology spread constraints.</p>

<p> </p>

<p> </p>

<p><strong>Question 13 | Multi Containers and Pod shared Volume</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Create a <em>Pod</em> named multi-container-playground in <em>Namespace</em> default with three containers, named c1, c2 and c3. There should be a volume attached to that <em>Pod</em> and mounted into every container, but the volume shouldn't be persisted or shared with other <em>Pods</em>.</p>

<p>Container c1 should be of image nginx:1.17.6-alpine and have the name of the node where its <em>Pod</em> is running available as environment variable MY_NODE_NAME.</p>

<p>Container c2 should be of image busybox:1.31.1 and write the output of the date command every second in the shared volume into file date.log. You can use while true; do date &gt;&gt; /your/vol/path/date.log; sleep 1; done for this.</p>

<p>Container c3 should be of image busybox:1.31.1 and constantly send the content of file date.log from the shared volume to stdout. You can use tail -f /your/vol/path/date.log for this.</p>

<p>Check the logs of container c3 to confirm correct setup.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we create the <em>Pod</em> template:</p>

<p>k run multi-container-playground --image=nginx:1.17.6-alpine $do &gt; 13.yaml</p>

<p>vim 13.yaml</p>

<p>And add the other containers and the commands they should execute:</p>

<p># 13.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: multi-container-playground</p>

<p>name: multi-container-playground</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.17.6-alpine</p>

<p>  name: c1                                                                      # change</p>

<p>  resources: {}</p>

<p>  env:                                                                          # add</p>

<p>  - name: MY_NODE_NAME                                                          # add</p>

<p>    valueFrom:                                                                  # add</p>

<p>      fieldRef:                                                                 # add</p>

<p>        fieldPath: spec.nodeName                                                # add</p>

<p>  volumeMounts:                                                                 # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    mountPath: /vol                                                             # add</p>

<p>- image: busybox:1.31.1                                                         # add</p>

<p>  name: c2                                                                      # add</p>

<p>  command: ["sh", "-c", "while true; do date &gt;&gt; /vol/date.log; sleep 1; done"]  # add</p>

<p>  volumeMounts:                                                                 # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    mountPath: /vol                                                             # add</p>

<p>- image: busybox:1.31.1                                                         # add</p>

<p>  name: c3                                                                      # add</p>

<p>  command: ["sh", "-c", "tail -f /vol/date.log"]                                # add</p>

<p>  volumeMounts:                                                                 # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    mountPath: /vol                                                             # add</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>volumes:                                                                        # add</p>

<p>  - name: vol                                                                   # add</p>

<p>    emptyDir: {}                                                                # add</p>

<p>status: {}</p>

<p>k -f 13.yaml create</p>

<p>Oh boy, lot's of requested things. We check if everything is good with the <em>Pod</em>:</p>

<p>➜ k get pod multi-container-playground</p>

<p>NAME                         READY   STATUS   RESTARTS   AGE</p>

<p>multi-container-playground   3/3     Running   0         95s</p>

<p>Good, then we check if container c1 has the requested node name as env variable:</p>

<p>➜ k exec multi-container-playground -c c1 -- env | grep MY</p>

<p>MY_NODE_NAME=cluster1-node2</p>

<p>And finally we check the logging:</p>

<p>➜ k logs multi-container-playground -c c3</p>

<p>Sat Dec 7 16:05:10 UTC 2077</p>

<p>Sat Dec 7 16:05:11 UTC 2077</p>

<p>Sat Dec 7 16:05:12 UTC 2077</p>

<p>Sat Dec 7 16:05:13 UTC 2077</p>

<p>Sat Dec 7 16:05:14 UTC 2077</p>

<p>Sat Dec 7 16:05:15 UTC 2077</p>

<p>Sat Dec 7 16:05:16 UTC 2077</p>

<p> </p>

<p> </p>

<p><strong>Question 14 | Find out Cluster Information</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>You're ask to find out following information about the cluster k8s-c1-H:</p>

<ol>
  <li>
    <p>How many controlplane nodes are available?</p>
  </li>
  <li>
    <p>How many worker nodes are available?</p>
  </li>
  <li>
    <p>What is the Service CIDR?</p>
  </li>
  <li>
    <p>Which Networking (or CNI Plugin) is configured and where is its config file?</p>
  </li>
  <li>
    <p>Which suffix will static pods have that run on cluster1-node1?</p>
  </li>
</ol>

<p>Write your answers into file /opt/course/14/cluster-info, structured like this:</p>

<p># /opt/course/14/cluster-info</p>

<p>1: [ANSWER]</p>

<p>2: [ANSWER]</p>

<p>3: [ANSWER]</p>

<p>4: [ANSWER]</p>

<p>5: [ANSWER]</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>How many controlplane and worker nodes are available?</strong></p>

<p>➜ k get node</p>

<p>NAME                   STATUS   ROLES         AGE   VERSION</p>

<p>cluster1-controlplane1 Ready   control-plane 27h   v1.29.0</p>

<p>cluster1-node1         Ready   &lt;none&gt;         27h   v1.29.0</p>

<p>cluster1-node2         Ready   &lt;none&gt;         27h   v1.29.0</p>

<p>We see one controlplane and two workers.</p>

<p> </p>

<p><strong>What is the Service CIDR?</strong></p>

<p>➜ ssh cluster1-controlplane1</p>

<p>➜ root@cluster1-controlplane1:~# cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep range</p>

<p>  - --service-cluster-ip-range=10.96.0.0/12</p>

<p> </p>

<p><strong>Which Networking (or CNI Plugin) is configured and where is its config file?</strong></p>

<p>➜ root@cluster1-controlplane1:~# find /etc/cni/net.d/</p>

<p>/etc/cni/net.d/</p>

<p>/etc/cni/net.d/10-weave.conflist</p>

<p>➜ root@cluster1-controlplane1:~# cat /etc/cni/net.d/10-weave.conflist</p>

<p>{</p>

<p>  "cniVersion": "0.3.0",</p>

<p>  "name": "weave",</p>

<p>...</p>

<p>By default the kubelet looks into /etc/cni/net.d to discover the CNI plugins. This will be the same on every controlplane and worker nodes.</p>

<p> </p>

<p><strong>Which suffix will static pods have that run on cluster1-node1?</strong></p>

<p>The suffix is the node hostname with a leading hyphen. It used to be -static in earlier Kubernetes versions.</p>

<p> </p>

<p><strong>Result</strong></p>

<p>The resulting /opt/course/14/cluster-info could look like:</p>

<p># /opt/course/14/cluster-info</p>

<p># How many controlplane nodes are available?</p>

<p>1: 1</p>

<p># How many worker nodes are available?</p>

<p>2: 2</p>

<p># What is the Service CIDR?</p>

<p>3: 10.96.0.0/12</p>

<p># Which Networking (or CNI Plugin) is configured and where is its config file?</p>

<p>4: Weave, /etc/cni/net.d/10-weave.conflist</p>

<p># Which suffix will static pods have that run on cluster1-node1?</p>

<p>5: -cluster1-node1</p>

<p> </p>

<p> </p>

<p><strong>Question 15 | Cluster Event Logging</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Write a command into /opt/course/15/cluster_events.sh which shows the latest events in the whole cluster, ordered by time (metadata.creationTimestamp). Use kubectl for it.</p>

<p>Now delete the kube-proxy <em>Pod</em> running on node cluster2-node1 and write the events this caused into /opt/course/15/pod_kill.log.</p>

<p>Finally kill the containerd container of the kube-proxy <em>Pod</em> on node cluster2-node1 and write the events into /opt/course/15/container_kill.log.</p>

<p>Do you notice differences in the events both actions caused?</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p># /opt/course/15/cluster_events.sh</p>

<p>kubectl get events -A --sort-by=.metadata.creationTimestamp</p>

<p>Now we delete the kube-proxy <em>Pod</em>:</p>

<p>k -n kube-system get pod -o wide | grep proxy # find pod running on cluster2-node1</p>

<p>k -n kube-system delete pod kube-proxy-z64cg</p>

<p>Now check the events:</p>

<p>sh /opt/course/15/cluster_events.sh</p>

<p>Write the events the killing caused into /opt/course/15/pod_kill.log:</p>

<p># /opt/course/15/pod_kill.log</p>

<p>kube-system   9s         Normal   Killing           pod/kube-proxy-jsv7t   ...</p>

<p>kube-system   3s         Normal   SuccessfulCreate daemonset/kube-proxy   ...</p>

<p>kube-system   &lt;unknown&gt;   Normal   Scheduled         pod/kube-proxy-m52sx   ...</p>

<p>default       2s         Normal   Starting         node/cluster2-node1 ...</p>

<p>kube-system   2s         Normal   Created           pod/kube-proxy-m52sx   ...</p>

<p>kube-system   2s         Normal   Pulled           pod/kube-proxy-m52sx   ...</p>

<p>kube-system   2s         Normal   Started           pod/kube-proxy-m52sx   ...</p>

<p>Finally we will try to provoke events by killing the container belonging to the container of the kube-proxy <em>Pod</em>:</p>

<p>➜ ssh cluster2-node1</p>

<p>➜ root@cluster2-node1:~# crictl ps | grep kube-proxy</p>

<p>1e020b43c4423   36c4ebbc9d979   About an hour ago   Running   kube-proxy     ...</p>

<p>➜ root@cluster2-node1:~# crictl rm 1e020b43c4423</p>

<p>1e020b43c4423</p>

<p>➜ root@cluster2-node1:~# crictl ps | grep kube-proxy</p>

<p>0ae4245707910   36c4ebbc9d979   17 seconds ago     Running   kube-proxy     ...    </p>

<p>We killed the main container (1e020b43c4423), but also noticed that a new container (0ae4245707910) was directly created. Thanks Kubernetes!</p>

<p>Now we see if this caused events again and we write those into the second file:</p>

<p>sh /opt/course/15/cluster_events.sh</p>

<p># /opt/course/15/container_kill.log</p>

<p>kube-system   13s         Normal   Created     pod/kube-proxy-m52sx   ...</p>

<p>kube-system   13s         Normal   Pulled       pod/kube-proxy-m52sx   ...</p>

<p>kube-system   13s         Normal   Started     pod/kube-proxy-m52sx   ...</p>

<p>Comparing the events we see that when we deleted the whole <em>Pod</em> there were more things to be done, hence more events. For example was the <em>DaemonSet</em> in the game to re-create the missing <em>Pod</em>. Where when we manually killed the main container of the <em>Pod</em>, the <em>Pod</em> would still exist but only its container needed to be re-created, hence less events.</p>

<p> </p>

<p> </p>

<p><strong>Question 16 | Namespaces and Api Resources</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Write the names of all namespaced Kubernetes resources (like <em>Pod</em>, <em>Secret</em>, <em>ConfigMap</em>...) into /opt/course/16/resources.txt.</p>

<p>Find the project-* <em>Namespace</em> with the highest number of Roles defined in it and write its name and amount of <em>Roles</em> into /opt/course/16/crowded-namespace.txt.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Namespace and Namespaces Resources</strong></p>

<p>Now we can get a list of all resources like:</p>

<p>k api-resources    # shows all</p>

<p>k api-resources -h # help always good</p>

<p>k api-resources --namespaced -o name &gt; /opt/course/16/resources.txt</p>

<p>Which results in the file:</p>

<p># /opt/course/16/resources.txt</p>

<p>bindings</p>

<p>configmaps</p>

<p>endpoints</p>

<p>events</p>

<p>limitranges</p>

<p>persistentvolumeclaims</p>

<p>pods</p>

<p>podtemplates</p>

<p>replicationcontrollers</p>

<p>resourcequotas</p>

<p>secrets</p>

<p>serviceaccounts</p>

<p>services</p>

<p>controllerrevisions.apps</p>

<p>daemonsets.apps</p>

<p>deployments.apps</p>

<p>replicasets.apps</p>

<p>statefulsets.apps</p>

<p>localsubjectaccessreviews.authorization.k8s.io</p>

<p>horizontalpodautoscalers.autoscaling</p>

<p>cronjobs.batch</p>

<p>jobs.batch</p>

<p>leases.coordination.k8s.io</p>

<p>events.events.k8s.io</p>

<p>ingresses.extensions</p>

<p>ingresses.networking.k8s.io</p>

<p>networkpolicies.networking.k8s.io</p>

<p>poddisruptionbudgets.policy</p>

<p>rolebindings.rbac.authorization.k8s.io</p>

<p>roles.rbac.authorization.k8s.io</p>

<p> </p>

<p><strong>Namespace with most Roles</strong></p>

<p>➜ k -n project-c13 get role --no-headers | wc -l</p>

<p>No resources found in project-c13 namespace.</p>

<p>0</p>

<p>➜ k -n project-c14 get role --no-headers | wc -l</p>

<p>300</p>

<p>➜ k -n project-hamster get role --no-headers | wc -l</p>

<p>No resources found in project-hamster namespace.</p>

<p>0</p>

<p>➜ k -n project-snake get role --no-headers | wc -l</p>

<p>No resources found in project-snake namespace.</p>

<p>0</p>

<p>➜ k -n project-tiger get role --no-headers | wc -l</p>

<p>No resources found in project-tiger namespace.</p>

<p>0</p>

<p>Finally we write the name and amount into the file:</p>

<p># /opt/course/16/crowded-namespace.txt</p>

<p>project-c14 with 300 resources</p>

<p> </p>

<p> </p>

<p><strong>Question 17 | Find Container of Pod and check info</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>In <em>Namespace</em> project-tiger create a <em>Pod</em> named tigers-reunite of image httpd:2.4.41-alpine with labels pod=container and container=pod. Find out on which node the <em>Pod</em> is scheduled. Ssh into that node and find the containerd container belonging to that <em>Pod</em>.</p>

<p>Using command crictl:</p>

<ol>
  <li>
    <p>Write the ID of the container and the info.runtimeType into /opt/course/17/pod-container.txt</p>
  </li>
  <li>
    <p>Write the logs of the container into /opt/course/17/pod-container.log</p>
  </li>
</ol>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we create the <em>Pod</em>:</p>

<p>k -n project-tiger run tigers-reunite \</p>

<p>--image=httpd:2.4.41-alpine \</p>

<p>--labels "pod=container,container=pod"</p>

<p>Next we find out the node it's scheduled on:</p>

<p>k -n project-tiger get pod -o wide</p>

<p># or fancy:</p>

<p>k -n project-tiger get pod tigers-reunite -o jsonpath="{.spec.nodeName}"</p>

<p>Then we ssh into that node and and check the container info:</p>

<p>➜ ssh cluster1-node2</p>

<p>➜ root@cluster1-node2:~# crictl ps | grep tigers-reunite</p>

<p>b01edbe6f89ed   54b0995a63052   5 seconds ago   Running       tigers-reunite ...</p>

<p>➜ root@cluster1-node2:~# crictl inspect b01edbe6f89ed | grep runtimeType</p>

<p>  "runtimeType": "io.containerd.runc.v2",</p>

<p>Then we fill the requested file (on the main terminal):</p>

<p># /opt/course/17/pod-container.txt</p>

<p>b01edbe6f89ed io.containerd.runc.v2</p>

<p>Finally we write the container logs in the second file:</p>

<p>ssh cluster1-node2 'crictl logs b01edbe6f89ed' &amp;&gt; /opt/course/17/pod-container.log</p>

<p>The &amp;&gt; in above's command redirects both the standard output and standard error.</p>

<p>You could also simply run crictl logs on the node and copy the content manually, if it's not a lot. The file should look like:</p>

<p># /opt/course/17/pod-container.log</p>

<p>AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.44.0.37. Set the 'ServerName' directive globally to suppress this message</p>

<p>AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.44.0.37. Set the 'ServerName' directive globally to suppress this message</p>

<p>[Mon Sep 13 13:32:18.555280 2021] [mpm_event:notice] [pid 1:tid 139929534545224] AH00489: Apache/2.4.41 (Unix) configured -- resuming normal operations</p>

<p>[Mon Sep 13 13:32:18.555610 2021] [core:notice] [pid 1:tid 139929534545224] AH00094: Command line: 'httpd -D FOREGROUND'</p>

<p> </p>

<p> </p>

<p><strong>Question 18 | Fix Kubelet</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>There seems to be an issue with the kubelet not running on cluster3-node1. Fix it and confirm that cluster has node cluster3-node1 available in Ready state afterwards. You should be able to schedule a <em>Pod</em> on cluster3-node1 afterwards.</p>

<p>Write the reason of the issue into /opt/course/18/reason.txt.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>The procedure on tasks like these should be to check if the kubelet is running, if not start it, then check its logs and correct errors if there are some.</p>

<p>Always helpful to check if other clusters already have some of the components defined and running, so you can copy and use existing config files. Though in this case it might not need to be necessary.</p>

<p>Check node status:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS     ROLES           AGE   VERSION</p>

<p>cluster3-controlplane1   Ready     control-plane   14d   v1.29.0</p>

<p>cluster3-node1           NotReady   &lt;none&gt;         14d   v1.29.0</p>

<p>First we check if the kubelet is running:</p>

<p>➜ ssh cluster3-node1</p>

<p>➜ root@cluster3-node1:~# ps aux | grep kubelet</p>

<p>root     29294 0.0 0.2 14856 1016 pts/0   S+   11:30   0:00 grep --color=auto kubelet</p>

<p>Nope, so we check if it's configured using systemd as service:</p>

<p>➜ root@cluster3-node1:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>    Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>  Drop-In: /usr/lib/systemd/system/kubelet.service.d</p>

<p>            └─10-kubeadm.conf</p>

<p>    Active: inactive (dead) (Result: exit-code) since Thu 2024-01-04 13:12:54 UTC; 1h 23min ago</p>

<p>      Docs: https://kubernetes.io/docs/</p>

<p>  Process: 27577 ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=&gt;</p>

<p>  Main PID: 27577 (code=exited, status=203/EXEC)</p>

<p>Jan 04 13:12:52 cluster3-node1 systemd[1]: kubelet.service: Main process exited, code=exited, status=203/EXEC</p>

<p>Jan 04 13:12:52 cluster3-node1 systemd[1]: kubelet.service: Failed with result 'exit-code'.</p>

<p>Jan 04 13:12:54 cluster3-node1 systemd[1]: Stopped kubelet: The Kubernetes Node Agent.</p>

<p>Yes, it's configured as a service with config at /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf, but we see it's inactive. Let's try to start it:</p>

<p>➜ root@cluster3-node1:~# service kubelet start</p>

<p>➜ root@cluster3-node1:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>    Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>  Drop-In: /usr/lib/systemd/system/kubelet.service.d</p>

<p>            └─10-kubeadm.conf</p>

<p>    Active: activating (auto-restart) (Result: exit-code) since Thu 2024-01-04 14:37:02 UTC; 6s ago</p>

<p>      Docs: https://kubernetes.io/docs/</p>

<p>  Process: 27935 ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=&gt;</p>

<p>  Main PID: 27935 (code=exited, status=203/EXEC)</p>

<p>Jan 04 14:37:02 cluster3-node1 systemd[1]: kubelet.service: Main process exited, code=exited, status=203/EXEC</p>

<p>Jan 04 14:37:02 cluster3-node1 systemd[1]: kubelet.service: Failed with result 'exit-code'.</p>

<p>We see it's trying to execute /usr/local/bin/kubelet with some parameters defined in its service config file. A good way to find errors and get more logs is to run the command manually (usually also with its parameters).</p>

<p>➜ root@cluster3-node1:~# /usr/local/bin/kubelet</p>

<p>-bash: /usr/local/bin/kubelet: No such file or directory</p>

<p>➜ root@cluster3-node1:~# whereis kubelet</p>

<p>kubelet: /usr/bin/kubelet</p>

<p>Another way would be to see the extended logging of a service like using journalctl -u kubelet.</p>

<p><strong>Well, there we have it, wrong path specified. Correct the path in file</strong> /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf and run:</p>

<p>vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf # fix binary path</p>

<p>systemctl daemon-reload</p>

<p>service kubelet restart</p>

<p>service kubelet status  # should now show running</p>

<p>Also the node should be available for the api server, <strong>give it a bit of time though</strong>:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster3-controlplane1   Ready   control-plane   14d   v1.29.0</p>

<p>cluster3-node1           Ready   &lt;none&gt;         14d   v1.29.0</p>

<p>Finally we write the reason into the file:</p>

<p># /opt/course/18/reason.txt</p>

<p>wrong path to kubelet binary specified in service config</p>

<p> </p>

<p> </p>

<p><strong>Question 19 | Create Secret and mount into Pod</strong></p>

<p> </p>

<p><strong>NOTE:</strong> This task can only be solved if questions 18 or 20 have been successfully implemented and the k8s-c3-CCC cluster has a functioning worker node</p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Do the following in a new <em>Namespace</em> secret. Create a <em>Pod</em> named secret-pod of image busybox:1.31.1 which should keep running for some time.</p>

<p>There is an existing <em>Secret</em> located at /opt/course/19/secret1.yaml, create it in the <em>Namespace</em> secret and mount it readonly into the <em>Pod</em> at /tmp/secret1.</p>

<p>Create a new <em>Secret</em> in <em>Namespace</em> secret called secret2 which should contain user=user1 and pass=1234. These entries should be available inside the <em>Pod's</em> container as environment variables APP_USER and APP_PASS.</p>

<p>Confirm everything is working.</p>

<p> </p>

<p><strong>Answer</strong></p>

<p>First we create the <em>Namespace</em> and the requested <em>Secrets</em> in it:</p>

<p>k create ns secret</p>

<p>cp /opt/course/19/secret1.yaml 19_secret1.yaml</p>

<p>vim 19_secret1.yaml</p>

<p>We need to adjust the <em>Namespace</em> for that <em>Secret</em>:</p>

<p># 19_secret1.yaml</p>

<p>apiVersion: v1</p>

<p>data:</p>

<p>halt: IyEgL2Jpbi9zaAo...</p>

<p>kind: Secret</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>name: secret1</p>

<p>namespace: secret # change</p>

<p>k -f 19_secret1.yaml create</p>

<p>Next we create the second <em>Secret</em>:</p>

<p>k -n secret create secret generic secret2 --from-literal=user=user1 --from-literal=pass=1234</p>

<p>Now we create the <em>Pod</em> template:</p>

<p>k -n secret run secret-pod --image=busybox:1.31.1 $do -- sh -c "sleep 5d" &gt; 19.yaml</p>

<p>vim 19.yaml</p>

<p>Then make the necessary changes:</p>

<p># 19.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: secret-pod</p>

<p>name: secret-pod</p>

<p>namespace: secret            # add</p>

<p>spec:</p>

<p>containers:</p>

<p>- args:</p>

<p>  - sh</p>

<p>  - -c</p>

<p>  - sleep 1d</p>

<p>  image: busybox:1.31.1</p>

<p>  name: secret-pod</p>

<p>  resources: {}</p>

<p>  env: # add</p>

<p>  - name: APP_USER # add</p>

<p>    valueFrom: # add</p>

<p>      secretKeyRef: # add</p>

<p>        name: secret2 # add</p>

<p>        key: user # add</p>

<p>  - name: APP_PASS # add</p>

<p>    valueFrom: # add</p>

<p>      secretKeyRef: # add</p>

<p>        name: secret2 # add</p>

<p>        key: pass # add</p>

<p>  volumeMounts:  # add</p>

<p>  - name: secret1 # add</p>

<p>    mountPath: /tmp/secret1 # add</p>

<p>    readOnly: true # add</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>volumes: # add</p>

<p>- name: secret1 # add</p>

<p>  secret: # add</p>

<p>    secretName: secret1 # add</p>

<p>status: {}</p>

<p>It might not be necessary in current K8s versions to specify the readOnly: true because it's the <a href="https://github.com/kubernetes/kubernetes/issues/62099">[default setting anyways]{.underline}</a>.</p>

<p>And execute:</p>

<p>k -f 19.yaml create</p>

<p>Finally we check if all is correct:</p>

<p>➜ k -n secret exec secret-pod -- env | grep APP</p>

<p>APP_PASS=1234</p>

<p>APP_USER=user1</p>

<p>➜ k -n secret exec secret-pod -- find /tmp/secret1</p>

<p>/tmp/secret1</p>

<p>/tmp/secret1/..data</p>

<p>/tmp/secret1/halt</p>

<p>/tmp/secret1/..2019_12_08_12_15_39.463036797</p>

<p>/tmp/secret1/..2019_12_08_12_15_39.463036797/halt</p>

<p>➜ k -n secret exec secret-pod -- cat /tmp/secret1/halt</p>

<p>#! /bin/sh</p>

<p>### BEGIN INIT INFO</p>

<p># Provides:         halt</p>

<p># Required-Start:</p>

<p># Required-Stop:</p>

<p># Default-Start:</p>

<p># Default-Stop:     0</p>

<p># Short-Description: Execute the halt command.</p>

<p># Description:</p>

<p>...</p>

<p>All is good.</p>

<p> </p>

<p> </p>

<p><strong>Question 20 | Update Kubernetes Version and join cluster</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Your coworker said node cluster3-node2 is running an older Kubernetes version and is not even part of the cluster. Update Kubernetes on that node to the exact version that's running on cluster3-controlplane1. Then add this node to the cluster. Use kubeadm for this.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Upgrade Kubernetes to cluster3-controlplane1 version</strong></p>

<p>Search in the docs for kubeadm upgrade: <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade">[https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade]{.underline}</a></p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE     VERSION</p>

<p>cluster3-controlplane1   Ready   control-plane   3h28m   v1.29.0</p>

<p>cluster3-node1           Ready   &lt;none&gt;         3h23m   v1.29.0</p>

<p>Controlplane node seems to be running Kubernetes 1.29.0. Node cluster3-node1 might not yet be part of the cluster depending on the completion of a previous task.</p>

<p>➜ ssh cluster3-node2</p>

<p>➜ root@cluster3-node2:~# kubectl version --short</p>

<p>Client Version: v1.28.5</p>

<p>Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3</p>

<p>The connection to the server localhost:8080 was refused - did you specify the right host or port?</p>

<p>➜ root@cluster3-node2:~# kubelet --version</p>

<p>Kubernetes v1.28.5</p>

<p>➜ root@cluster3-node2:~# kubeadm version</p>

<p>kubeadm version: &amp;version.Info{Major:"1", Minor:"29", GitVersion:"v1.29.0", GitCommit:"3f7a50f38688eb332e2a1b013678c6435d539ae6", GitTreeState:"clean", BuildDate:"2023-12-13T08:50:10Z", GoVersion:"go1.21.5", Compiler:"gc", Platform:"linux/amd64"}</p>

<p>Above we can see that kubeadm is already installed in the wanted version, so we don't need to install it. Hence we can run:</p>

<p>➜ root@cluster3-node2:~# kubeadm upgrade node</p>

<p>couldn't create a Kubernetes client from file "/etc/kubernetes/kubelet.conf": failed to load admin kubeconfig: open /etc/kubernetes/kubelet.conf: no such file or directory</p>

<p>To see the stack trace of this error execute with --v=5 or higher</p>

<p>This is usually the proper command to upgrade a node. But this error means that this node was never even initialised, so nothing to update here. This will be done later using kubeadm join. For now we can continue with kubelet and kubectl:</p>

<p>➜ root@cluster3-node2:~# apt update</p>

<p>Hit:1 http://ppa.launchpad.net/rmescandon/yq/ubuntu focal InRelease</p>

<p>Hit:3 http://us.archive.ubuntu.com/ubuntu focal InRelease                                                                                            </p>

<p>Hit:4 http://security.ubuntu.com/ubuntu focal-security InRelease    </p>

<p>Hit:2 https://prod-cdn.packages.k8s.io/repositories/isv:/kubernetes:/core:/stable:/v1.28/deb InRelease</p>

<p>Hit:5 https://prod-cdn.packages.k8s.io/repositories/isv:/kubernetes:/core:/stable:/v1.29/deb InRelease</p>

<p>Get:6 http://us.archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]</p>

<p>Hit:7 http://us.archive.ubuntu.com/ubuntu focal-backports InRelease</p>

<p>Get:8 http://us.archive.ubuntu.com/ubuntu focal-updates/main i386 Packages [919 kB]</p>

<p>Get:9 http://us.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [3,023 kB]</p>

<p>Get:10 http://us.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [1,141 kB]</p>

<p>Get:11 http://us.archive.ubuntu.com/ubuntu focal-updates/universe i386 Packages [762 kB]</p>

<p>Fetched 5,959 kB in 3s (2,049 kB/s)                  </p>

<p>Reading package lists... Done</p>

<p>Building dependency tree      </p>

<p>Reading state information... Done</p>

<p>222 packages can be upgraded. Run 'apt list --upgradable' to see them.</p>

<p>➜ root@cluster3-node2:~# apt show kubectl -a | grep 1.29</p>

<p>Version: 1.29.0-1.1</p>

<p>APT-Sources: https://pkgs.k8s.io/core:/stable:/v1.29/deb Packages</p>

<p>➜ root@cluster3-node2:~# apt install kubectl=1.29.0-1.1 kubelet=1.29.0-1.1</p>

<p>Reading package lists... Done</p>

<p>Building dependency tree      </p>

<p>Reading state information... Done</p>

<p>The following packages will be upgraded:</p>

<p>kubectl kubelet</p>

<p>2 upgraded, 0 newly installed, 0 to remove and 220 not upgraded.</p>

<p>Need to get 30.3 MB of archives.</p>

<p>After this operation, 782 kB of additional disk space will be used.</p>

<p>Get:1 https://prod-cdn.packages.k8s.io/repositories/isv:/kubernetes:/core:/stable:/v1.29/deb kubectl 1.29.0-1.1 [10.5 MB]</p>

<p>Get:2 https://prod-cdn.packages.k8s.io/repositories/isv:/kubernetes:/core:/stable:/v1.29/deb kubelet 1.29.0-1.1 [19.8 MB]</p>

<p>Fetched 30.3 MB in 1s (40.8 MB/s)</p>

<p>(Reading database ... 112588 files and directories currently installed.)</p>

<p>Preparing to unpack .../kubectl_1.29.0-1.1_amd64.deb ...</p>

<p>Unpacking kubectl (1.29.0-1.1) over (1.28.5-1.1) ...</p>

<p>Preparing to unpack .../kubelet_1.29.0-1.1_amd64.deb ...</p>

<p>Unpacking kubelet (1.29.0-1.1) over (1.28.5-1.1) ...</p>

<p>Setting up kubectl (1.29.0-1.1) ...</p>

<p>Setting up kubelet (1.29.0-1.1) ...</p>

<p>➜ root@cluster3-node2:~# kubelet --version</p>

<p>Kubernetes v1.29.0</p>

<p>Now we're up to date with kubeadm, kubectl and kubelet. Restart the kubelet:</p>

<p>➜ root@cluster3-node2:~# service kubelet restart</p>

<p>➜ root@cluster3-node2:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>    Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>  Drop-In: /usr/lib/systemd/system/kubelet.service.d</p>

<p>            └─10-kubeadm.conf</p>

<p>    Active: activating (auto-restart) (Result: exit-code) since Thu 2024-01-04 14:01:11 UTC; 2s ago</p>

<p>      Docs: https://kubernetes.io/docs/</p>

<p>  Process: 43818 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=1/FAIL&gt;</p>

<p>  Main PID: 43818 (code=exited, status=1/FAILURE)</p>

<p>Jan 04 14:01:11 cluster3-node2 systemd[1]: kubelet.service: Main process exited, code=exited, status=1/FAILURE</p>

<p>Jan 04 14:01:11 cluster3-node2 systemd[1]: kubelet.service: Failed with result 'exit-code'.</p>

<p>These errors occur because we still need to run kubeadm join to join the node into the cluster. Let's do this in the next step.</p>

<p> </p>

<p><strong>Add cluster3-node2 to cluster</strong></p>

<p>First we log into the controlplane1 and generate a new TLS bootstrap token, also printing out the join command:</p>

<p>➜ ssh cluster3-controlplane1</p>

<p>➜ root@cluster3-controlplane1:~# kubeadm token create --print-join-command</p>

<p>kubeadm join 192.168.100.31:6443 --token pbuqzw.83kz9uju8talblrl --discovery-token-ca-cert-hash sha256:eae975465f73f316f322bcdd5eb6a5a53f08662ecb407586561cdc06f74bf7b2</p>

<p>➜ root@cluster3-controlplane1:~# kubeadm token list</p>

<p>TOKEN                     TTL         EXPIRES               ...</p>

<p>dm3ws5.hga8xkwpp0f2lk4q   20h         2024-01-05T10:28:19Z</p>

<p>pbuqzw.83kz9uju8talblrl   23h         2024-01-05T14:01:38Z</p>

<p>rhjon6.qra3to1sjf2xnn0l   &lt;forever&gt;   &lt;never&gt;</p>

<p>We see the expiration of 23h for our token, we could adjust this by passing the ttl argument.</p>

<p>Next we connect again to cluster3-node2 and simply execute the join command:</p>

<p>➜ ssh cluster3-node2</p>

<p>➜ root@cluster3-node2:~# kubeadm join 192.168.100.31:6443 --token pbuqzw.83kz9uju8talblrl --discovery-token-ca-cert-hash sha256:eae975465f73f316f322bcdd5eb6a5a53f08662ecb407586561cdc06f74bf7b2</p>

<p>[preflight] Running pre-flight checks</p>

<p>[preflight] Reading configuration from the cluster...</p>

<p>[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'</p>

<p>[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</p>

<p>[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</p>

<p>[kubelet-start] Starting the kubelet</p>

<p>[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</p>

<p>This node has joined the cluster:</p>

<p>* Certificate signing request was sent to apiserver and a response was received.</p>

<p>* The Kubelet was informed of the new secure connection details.</p>

<p>Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</p>

<p>➜ root@cluster3-node2:~# service kubelet status</p>

<p>● kubelet.service - kubelet: The Kubernetes Node Agent</p>

<p>    Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)</p>

<p>  Drop-In: /usr/lib/systemd/system/kubelet.service.d</p>

<p>            └─10-kubeadm.conf</p>

<p>    Active: active (running) since Thu 2024-01-04 14:02:45 UTC; 13s ago</p>

<p>      Docs: https://kubernetes.io/docs/</p>

<p>  Main PID: 44103 (kubelet)</p>

<p>    Tasks: 10 (limit: 462)</p>

<p>    Memory: 55.5M</p>

<p>    CGroup: /system.slice/kubelet.service</p>

<p>            └─44103 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/k&gt;</p>

<p>If you have troubles with kubeadm join you might need to run kubeadm reset.</p>

<p>This looks great though for us. Finally we head back to the main terminal and check the node status:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS     ROLES           AGE     VERSION</p>

<p>cluster3-controlplane1   Ready     control-plane   3h34m   v1.29.0</p>

<p>cluster3-node1           Ready     &lt;none&gt;         3h29m   v1.29.0</p>

<p>cluster3-node2           NotReady   &lt;none&gt;         20s     v1.29.0</p>

<p>Give it a bit of time till the node is ready.</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE     VERSION</p>

<p>cluster3-controlplane1   Ready   control-plane   3h34m   v1.29.0</p>

<p>cluster3-node1           Ready   &lt;none&gt;         3h29m   v1.29.0</p>

<p>cluster3-node2           Ready   &lt;none&gt;         27s     v1.29.0</p>

<p>We see cluster3-node2 is now available and up to date.</p>

<p> </p>

<p> </p>

<p><strong>Question 21 | Create a Static Pod and Service</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Create a Static Pod named my-static-pod in <em>Namespace</em> default on cluster3-controlplane1. It should be of image nginx:1.16-alpine and have resource requests for 10m CPU and 20Mi memory.</p>

<p>Then create a NodePort <em>Service</em> named static-pod-service which exposes that static <em>Pod</em> on port 80 and check if it has <em>Endpoints</em> and if it's reachable through the cluster3-controlplane1 internal IP address. You can connect to the internal node IPs from your main terminal.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>➜ ssh cluster3-controlplane1</p>

<p>➜ root@cluster1-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>➜ root@cluster1-controlplane1:~# kubectl run my-static-pod \</p>

<p>--image=nginx:1.16-alpine \</p>

<p>-o yaml --dry-run=client &gt; my-static-pod.yaml</p>

<p>Then edit the my-static-pod.yaml to add the requested resource requests:</p>

<p># /etc/kubernetes/manifests/my-static-pod.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: my-static-pod</p>

<p>name: my-static-pod</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.16-alpine</p>

<p>  name: my-static-pod</p>

<p>  resources:</p>

<p>    requests:</p>

<p>      cpu: 10m</p>

<p>      memory: 20Mi</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p> </p>

<p>And make sure it's running:</p>

<p>➜ k get pod -A | grep my-static</p>

<p>NAMESPACE     NAME                             READY   STATUS   ...   AGE</p>

<p>default       my-static-pod-cluster3-controlplane1   1/1     Running ...   22s</p>

<p>Now we expose that static <em>Pod</em>:</p>

<p>k expose pod my-static-pod-cluster3-controlplane1 \</p>

<p>--name static-pod-service \</p>

<p>--type=NodePort \</p>

<p>--port 80</p>

<p>This would generate a <em>Service</em> like:</p>

<p># kubectl expose pod my-static-pod-cluster3-controlplane1 --name static-pod-service --type=NodePort --port 80</p>

<p>apiVersion: v1</p>

<p>kind: Service</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: my-static-pod</p>

<p>name: static-pod-service</p>

<p>spec:</p>

<p>ports:</p>

<p>- port: 80</p>

<p>  protocol: TCP</p>

<p>  targetPort: 80</p>

<p>selector:</p>

<p>  run: my-static-pod</p>

<p>type: NodePort</p>

<p>status:</p>

<p>loadBalancer: {}</p>

<p>Then run and test:</p>

<p>➜ k get svc,ep -l run=my-static-pod</p>

<p>NAME                         TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)       AGE</p>

<p>service/static-pod-service   NodePort   10.99.168.252   &lt;none&gt;       80:30352/TCP   30s</p>

<p>NAME                           ENDPOINTS     AGE</p>

<p>endpoints/static-pod-service   10.32.0.4:80   30s</p>

<p>Looking good.</p>

<p> </p>

<p> </p>

<p><strong>Question 22 | Check how long certificates are valid</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Check how long the kube-apiserver server certificate is valid on cluster2-controlplane1. Do this with openssl or cfssl. Write the exipiration date into /opt/course/22/expiration.</p>

<p>Also run the correct kubeadm command to list the expiration dates and confirm both methods show the same date.</p>

<p>Write the correct kubeadm command that would renew the apiserver server certificate into /opt/course/22/kubeadm-renew-certs.sh.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First let's find that certificate:</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# find /etc/kubernetes/pki | grep apiserver</p>

<p>/etc/kubernetes/pki/apiserver.crt</p>

<p>/etc/kubernetes/pki/apiserver-etcd-client.crt</p>

<p>/etc/kubernetes/pki/apiserver-etcd-client.key</p>

<p>/etc/kubernetes/pki/apiserver-kubelet-client.crt</p>

<p>/etc/kubernetes/pki/apiserver.key</p>

<p>/etc/kubernetes/pki/apiserver-kubelet-client.key</p>

<p>Next we use openssl to find out the expiration date:</p>

<p>➜ root@cluster2-controlplane1:~# openssl x509 -noout -text -in /etc/kubernetes/pki/apiserver.crt | grep Validity -A2</p>

<p>      Validity</p>

<p>          Not Before: Dec 20 18:05:20 2022 GMT</p>

<p>          Not After : Dec 20 18:05:20 2023 GMT</p>

<p>There we have it, so we write it in the required location on our main terminal:</p>

<p># /opt/course/22/expiration</p>

<p>Dec 20 18:05:20 2023 GMT</p>

<p>And we use the feature from kubeadm to get the expiration too:</p>

<p>➜ root@cluster2-controlplane1:~# kubeadm certs check-expiration | grep apiserver</p>

<p>apiserver               Jan 14, 2022 18:49 UTC   363d       ca               no      </p>

<p>apiserver-etcd-client   Jan 14, 2022 18:49 UTC   363d       etcd-ca         no      </p>

<p>apiserver-kubelet-client Jan 14, 2022 18:49 UTC   363d       ca               no</p>

<p>Looking good. And finally we write the command that would renew all certificates into the requested location:</p>

<p># /opt/course/22/kubeadm-renew-certs.sh</p>

<p>kubeadm certs renew apiserver</p>

<p> </p>

<p> </p>

<p><strong>Question 23 | Kubelet client/server cert info</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Node cluster2-node1 has been added to the cluster using kubeadm and TLS bootstrapping.</p>

<p>Find the "Issuer" and "Extended Key Usage" values of the cluster2-node1:</p>

<ol>
  <li>
    <p>kubelet <strong>client</strong> certificate, the one used for outgoing connections to the kube-apiserver.</p>
  </li>
  <li>
    <p>kubelet <strong>server</strong> certificate, the one used for incoming connections from the kube-apiserver.</p>
  </li>
</ol>

<p>Write the information into file /opt/course/23/certificate-info.txt.</p>

<p>Compare the "Issuer" and "Extended Key Usage" fields of both certificates and make sense of these.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>To find the correct kubelet certificate directory, we can look for the default value of the --cert-dir parameter for the kubelet. For this search for "kubelet" in the Kubernetes docs which will lead to: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet">[https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet]{.underline}</a>. We can check if another certificate directory has been configured using ps aux or in /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf.</p>

<p>First we check the kubelet client certificate:</p>

<p>➜ ssh cluster2-node1</p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem | grep Issuer</p>

<p>      Issuer: CN = kubernetes</p>

<p>       </p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem | grep "Extended Key Usage" -A1</p>

<p>          X509v3 Extended Key Usage:</p>

<p>              TLS Web Client Authentication</p>

<p>Next we check the kubelet server certificate:</p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet.crt | grep Issuer</p>

<p>Issuer: CN = cluster2-node1-ca@1588186506</p>

<p>➜ root@cluster2-node1:~# openssl x509 -noout -text -in /var/lib/kubelet/pki/kubelet.crt | grep "Extended Key Usage" -A1</p>

<p>X509v3 Extended Key Usage:</p>

<p>              TLS Web Server Authentication</p>

<p>We see that the server certificate was generated on the worker node itself and the client certificate was issued by the Kubernetes api. The "Extended Key Usage" also shows if it's for client or server authentication.</p>

<p>More about this: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping">[https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping]{.underline}</a></p>

<p> </p>

<p> </p>

<p><strong>Question 24 | NetworkPolicy</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There was a security incident where an intruder was able to access the whole cluster from a single hacked backend <em>Pod</em>.</p>

<p>To prevent this create a <em>NetworkPolicy</em> called np-backend in <em>Namespace</em> project-snake. It should allow the backend-* <em>Pods</em> only to:</p>

<ul>
  <li>
    <p>connect to db1-* <em>Pods</em> on port 1111</p>
  </li>
  <li>
    <p>connect to db2-* <em>Pods</em> on port 2222</p>
  </li>
</ul>

<p>Use the app label of <em>Pods</em> in your policy.</p>

<p>After implementation, connections from backend-* <em>Pods</em> to vault-* <em>Pods</em> on port 3333 should for example no longer work.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>First we look at the existing <em>Pods</em> and their labels:</p>

<p>➜ k -n project-snake get pod</p>

<p>NAME       READY   STATUS   RESTARTS   AGE</p>

<p>backend-0   1/1     Running   0         8s</p>

<p>db1-0       1/1     Running   0         8s</p>

<p>db2-0       1/1     Running   0         10s</p>

<p>vault-0     1/1     Running   0         10s</p>

<p>➜ k -n project-snake get pod -L app</p>

<p>NAME       READY   STATUS   RESTARTS   AGE     APP</p>

<p>backend-0   1/1     Running   0         3m15s   backend</p>

<p>db1-0       1/1     Running   0         3m15s   db1</p>

<p>db2-0       1/1     Running   0         3m17s   db2</p>

<p>vault-0     1/1     Running   0         3m17s   vault</p>

<p>We test the current connection situation and see nothing is restricted:</p>

<p>➜ k -n project-snake get pod -o wide</p>

<p>NAME       READY   STATUS   RESTARTS   AGE     IP         ...</p>

<p>backend-0   1/1     Running   0         4m14s   10.44.0.24 ...</p>

<p>db1-0       1/1     Running   0         4m14s   10.44.0.25 ...</p>

<p>db2-0       1/1     Running   0         4m16s   10.44.0.23 ...</p>

<p>vault-0     1/1     Running   0         4m16s   10.44.0.22 ...</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.25:1111</p>

<p>database one</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.23:2222</p>

<p>database two</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.22:3333</p>

<p>vault secret storage</p>

<p>Now we create the <em>NP</em> by copying and chaning an example from the k8s docs:</p>

<p>vim 24_np.yaml</p>

<p># 24_np.yaml</p>

<p>apiVersion: networking.k8s.io/v1</p>

<p>kind: NetworkPolicy</p>

<p>metadata:</p>

<p>name: np-backend</p>

<p>namespace: project-snake</p>

<p>spec:</p>

<p>podSelector:</p>

<p>  matchLabels:</p>

<p>    app: backend</p>

<p>policyTypes:</p>

<p>  - Egress                    # policy is only about Egress</p>

<p>egress:</p>

<p>  -                           # first rule</p>

<p>    to:                           # first condition "to"</p>

<p>    - podSelector:</p>

<p>        matchLabels:</p>

<p>          app: db1</p>

<p>    ports:                        # second condition "port"</p>

<p>    - protocol: TCP</p>

<p>      port: 1111</p>

<p>  -                           # second rule</p>

<p>    to:                           # first condition "to"</p>

<p>    - podSelector:</p>

<p>        matchLabels:</p>

<p>          app: db2</p>

<p>    ports:    # second condition "port"</p>

<p>    - protocol: TCP</p>

<p>      port: 2222</p>

<p>The <em>NP</em> above has two rules with two conditions each, it can be read as:</p>

<p>allow outgoing traffic if:</p>

<p>(destination pod has label app=db1 AND port is 1111)</p>

<p>OR</p>

<p>(destination pod has label app=db2 AND port is 2222)</p>

<p> </p>

<p><strong>Wrong example</strong></p>

<p>Now let's shortly look at a wrong example:</p>

<p># WRONG</p>

<p>apiVersion: networking.k8s.io/v1</p>

<p>kind: NetworkPolicy</p>

<p>metadata:</p>

<p>name: np-backend</p>

<p>namespace: project-snake</p>

<p>spec:</p>

<p>podSelector:</p>

<p>  matchLabels:</p>

<p>    app: backend</p>

<p>policyTypes:</p>

<p>  - Egress</p>

<p>egress:</p>

<p>  -                           # first rule</p>

<p>    to:                           # first condition "to"</p>

<p>    - podSelector:                    # first "to" possibility</p>

<p>        matchLabels:</p>

<p>          app: db1</p>

<p>    - podSelector:                    # second "to" possibility</p>

<p>        matchLabels:</p>

<p>          app: db2</p>

<p>    ports:                        # second condition "ports"</p>

<p>    - protocol: TCP                   # first "ports" possibility</p>

<p>      port: 1111</p>

<p>    - protocol: TCP                   # second "ports" possibility</p>

<p>      port: 2222</p>

<p>The <em>NP</em> above has one rule with two conditions and two condition-entries each, it can be read as:</p>

<p>allow outgoing traffic if:</p>

<p>(destination pod has label app=db1 OR destination pod has label app=db2)</p>

<p>AND</p>

<p>(destination port is 1111 OR destination port is 2222)</p>

<p>Using this <em>NP</em> it would still be possible for backend-* <em>Pods</em> to connect to db2-* <em>Pods</em> on port 1111 for example which should be forbidden.</p>

<p> </p>

<p><strong>Create NetworkPolicy</strong></p>

<p>We create the correct <em>NP</em>:</p>

<p>k -f 24_np.yaml create</p>

<p>And test again:</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.25:1111</p>

<p>database one</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.23:2222</p>

<p>database two</p>

<p>➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.22:3333</p>

<p>\^C</p>

<p>Also helpful to use kubectl describe on the <em>NP</em> to see how k8s has interpreted the policy.</p>

<p>Great, looking more secure. Task done.</p>

<p> </p>

<p> </p>

<p><strong>Question 25 | Etcd Snapshot Save and Restore</strong></p>

<p> </p>

<p>Use context: kubectl config use-context k8s-c3-CCC</p>

<p> </p>

<p>Make a backup of etcd running on cluster3-controlplane1 and save it on the controlplane node at /tmp/etcd-backup.db.</p>

<p>Then create any kind of <em>Pod</em> in the cluster.</p>

<p>Finally restore the backup, confirm the cluster is still working and that the created <em>Pod</em> is no longer with us.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Etcd Backup</strong></p>

<p>First we log into the controlplane and try to create a snapshop of etcd:</p>

<p>➜ ssh cluster3-controlplane1</p>

<p>➜ root@cluster3-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd-backup.db</p>

<p>Error: rpc error: code = Unavailable desc = transport is closing</p>

<p>But it fails because we need to authenticate ourselves. For the necessary information we can check the etc manifest:</p>

<p>➜ root@cluster3-controlplane1:~# vim /etc/kubernetes/manifests/etcd.yaml</p>

<p>We only check the etcd.yaml for necessary information we don't change it.</p>

<p># /etc/kubernetes/manifests/etcd.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: etcd</p>

<p>  tier: control-plane</p>

<p>name: etcd</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - etcd</p>

<p>  - --advertise-client-urls=https://192.168.100.31:2379</p>

<p>  - --cert-file=/etc/kubernetes/pki/etcd/server.crt # use</p>

<p>  - --client-cert-auth=true</p>

<p>  - --data-dir=/var/lib/etcd</p>

<p>  - --initial-advertise-peer-urls=https://192.168.100.31:2380</p>

<p>  - --initial-cluster=cluster3-controlplane1=https://192.168.100.31:2380</p>

<p>  - --key-file=/etc/kubernetes/pki/etcd/server.key # use</p>

<p>  - --listen-client-urls=https://127.0.0.1:2379,https://192.168.100.31:2379 # use</p>

<p>  - --listen-metrics-urls=http://127.0.0.1:2381</p>

<p>  - --listen-peer-urls=https://192.168.100.31:2380</p>

<p>  - --name=cluster3-controlplane1</p>

<p>  - --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt</p>

<p>  - --peer-client-cert-auth=true</p>

<p>  - --peer-key-file=/etc/kubernetes/pki/etcd/peer.key</p>

<p>  - --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt # use</p>

<p>  - --snapshot-count=10000</p>

<p>  - --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>  image: k8s.gcr.io/etcd:3.3.15-0</p>

<p>  imagePullPolicy: IfNotPresent</p>

<p>  livenessProbe:</p>

<p>    failureThreshold: 8</p>

<p>    httpGet:</p>

<p>      host: 127.0.0.1</p>

<p>      path: /health</p>

<p>      port: 2381</p>

<p>      scheme: HTTP</p>

<p>    initialDelaySeconds: 15</p>

<p>    timeoutSeconds: 15</p>

<p>  name: etcd</p>

<p>  resources: {}</p>

<p>  volumeMounts:</p>

<p>  - mountPath: /var/lib/etcd</p>

<p>    name: etcd-data</p>

<p>  - mountPath: /etc/kubernetes/pki/etcd</p>

<p>    name: etcd-certs</p>

<p>hostNetwork: true</p>

<p>priorityClassName: system-cluster-critical</p>

<p>volumes:</p>

<p>- hostPath:</p>

<p>    path: /etc/kubernetes/pki/etcd</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-certs</p>

<p>- hostPath:</p>

<p>    path: /var/lib/etcd # important</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-data</p>

<p>status: {}</p>

<p>But we also know that the api-server is connecting to etcd, so we can check how its manifest is configured:</p>

<p>➜ root@cluster3-controlplane1:~# cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd</p>

<p>  - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>  - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt</p>

<p>  - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key</p>

<p>  - --etcd-servers=https://127.0.0.1:2379</p>

<p>We use the authentication information and pass it to etcdctl:</p>

<p>➜ root@cluster3-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd-backup.db \</p>

<p>--cacert /etc/kubernetes/pki/etcd/ca.crt \</p>

<p>--cert /etc/kubernetes/pki/etcd/server.crt \</p>

<p>--key /etc/kubernetes/pki/etcd/server.key</p>

<p>Snapshot saved at /tmp/etcd-backup.db</p>

<p> </p>

<p><strong>NOTE:</strong> Dont use snapshot status because it can alter the snapshot file and render it invalid</p>

<p> </p>

<p><strong>Etcd restore</strong></p>

<p>Now create a <em>Pod</em> in the cluster and wait for it to be running:</p>

<p>➜ root@cluster3-controlplane1:~# kubectl run test --image=nginx</p>

<p>pod/test created</p>

<p>➜ root@cluster3-controlplane1:~# kubectl get pod -l run=test -w</p>

<p>NAME   READY   STATUS   RESTARTS   AGE</p>

<p>test   1/1     Running   0         60s</p>

<p> </p>

<p><strong>NOTE:</strong> If you didn't solve questions 18 or 20 and cluster3 doesn't have a ready worker node then the created pod might stay in a Pending state. This is still ok for this task.</p>

<p> </p>

<p>Next we stop all controlplane components:</p>

<p>root@cluster3-controlplane1:~# cd /etc/kubernetes/manifests/</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# mv * ..</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# watch crictl ps</p>

<p>Now we restore the snapshot into a specific directory:</p>

<p>➜ root@cluster3-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot restore /tmp/etcd-backup.db \</p>

<p>--data-dir /var/lib/etcd-backup \</p>

<p>--cacert /etc/kubernetes/pki/etcd/ca.crt \</p>

<p>--cert /etc/kubernetes/pki/etcd/server.crt \</p>

<p>--key /etc/kubernetes/pki/etcd/server.key</p>

<p>2020-09-04 16:50:19.650804 I | mvcc: restore compact to 9935</p>

<p>2020-09-04 16:50:19.659095 I | etcdserver/membership: added member 8e9e05c52164694d [http://localhost:2380] to cluster cdf818194e3a8c32</p>

<p>We could specify another host to make the backup from by using etcdctl --endpoints http://IP, but here we just use the default value which is: http://127.0.0.1:2379,http://127.0.0.1:4001.</p>

<p>The restored files are located at the new folder /var/lib/etcd-backup, now we have to tell etcd to use that directory:</p>

<p>➜ root@cluster3-controlplane1:~# vim /etc/kubernetes/etcd.yaml</p>

<p># /etc/kubernetes/etcd.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: etcd</p>

<p>  tier: control-plane</p>

<p>name: etcd</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>...</p>

<p>  - mountPath: /etc/kubernetes/pki/etcd</p>

<p>    name: etcd-certs</p>

<p>hostNetwork: true</p>

<p>priorityClassName: system-cluster-critical</p>

<p>volumes:</p>

<p>- hostPath:</p>

<p>    path: /etc/kubernetes/pki/etcd</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-certs</p>

<p>- hostPath:</p>

<p>    path: /var/lib/etcd-backup # change</p>

<p>    type: DirectoryOrCreate</p>

<p>  name: etcd-data</p>

<p>status: {}</p>

<p>Now we move all controlplane yaml again into the manifest directory. Give it some time (up to several minutes) for etcd to restart and for the api-server to be reachable again:</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# mv ../*.yaml .</p>

<p>root@cluster3-controlplane1:/etc/kubernetes/manifests# watch crictl ps</p>

<p>Then we check again for the <em>Pod</em>:</p>

<p>➜ root@cluster3-controlplane1:~# kubectl get pod -l run=test</p>

<p>No resources found in default namespace.</p>

<p>Awesome, backup and restore worked as our pod is gone.</p>

<p> </p>

<p> </p>

<p><strong>Extra Question 1 | Find Pods first to be terminated</strong></p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>Check all available <em>Pods</em> in the <em>Namespace</em> project-c13 and find the names of those that would probably be terminated first if the <em>nodes</em> run out of resources (cpu or memory) to schedule all <em>Pods</em>. Write the <em>Pod</em> names into /opt/course/e1/pods-not-stable.txt.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>When available cpu or memory resources on the nodes reach their limit, Kubernetes will look for <em>Pods</em> that are using more resources than they requested. These will be the first candidates for termination. If some <em>Pods</em> containers have no resource requests/limits set, then by default those are considered to use more than requested.</p>

<p>Kubernetes assigns Quality of Service classes to <em>Pods</em> based on the defined resources and limits, read more here: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod">[https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod]{.underline}</a></p>

<p>Hence we should look for <em>Pods</em> without resource requests defined, we can do this with a manual approach:</p>

<p>k -n project-c13 describe pod | less -p Requests # describe all pods and highlight Requests</p>

<p>Or we do:</p>

<p>k -n project-c13 describe pod | egrep "\^(Name:|   Requests:)" -A1</p>

<p>We see that the <em>Pods</em> of <em>Deployment</em> c13-3cc-runner-heavy don't have any resources requests specified. Hence our answer would be:</p>

<p># /opt/course/e1/pods-not-stable.txt</p>

<p>c13-3cc-runner-heavy-65588d7d6-djtv9map</p>

<p>c13-3cc-runner-heavy-65588d7d6-v8kf5map</p>

<p>c13-3cc-runner-heavy-65588d7d6-wwpb4map</p>

<p>o3db-0</p>

<p>o3db-1 # maybe not existing if already removed via previous scenario</p>

<p>To automate this process you could use jsonpath like this:</p>

<p>➜ k -n project-c13 get pod \</p>

<p>-o jsonpath="{range .items[*]} {.metadata.name}{.spec.containers[*].resources}{'\n'}"</p>

<p>c13-2x3-api-86784557bd-cgs8gmap[requests:map[cpu:50m memory:20Mi]]</p>

<p>c13-2x3-api-86784557bd-lnxvjmap[requests:map[cpu:50m memory:20Mi]]</p>

<p>c13-2x3-api-86784557bd-mnp77map[requests:map[cpu:50m memory:20Mi]]</p>

<p>c13-2x3-web-769c989898-6hbgtmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-g57nqmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-hfd5vmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-jfx64map[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-r89mgmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-2x3-web-769c989898-wtgxlmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-runner-98c8b5469-dzqhrmap[requests:map[cpu:30m memory:10Mi]]</p>

<p>c13-3cc-runner-98c8b5469-hbtdvmap[requests:map[cpu:30m memory:10Mi]]</p>

<p>c13-3cc-runner-98c8b5469-n9lswmap[requests:map[cpu:30m memory:10Mi]]</p>

<p>c13-3cc-runner-heavy-65588d7d6-djtv9map[]</p>

<p>c13-3cc-runner-heavy-65588d7d6-v8kf5map[]</p>

<p>c13-3cc-runner-heavy-65588d7d6-wwpb4map[]</p>

<p>c13-3cc-web-675456bcd-glpq6map[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-web-675456bcd-knlpxmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-web-675456bcd-nfhp9map[requests:map[cpu:50m memory:10Mi]]</p>

<p>c13-3cc-web-675456bcd-twn7mmap[requests:map[cpu:50m memory:10Mi]]</p>

<p>o3db-0{}</p>

<p>o3db-1{}</p>

<p>This lists all <em>Pod</em> names and their requests/limits, hence we see the three <em>Pods</em> without those defined.</p>

<p>Or we look for the Quality of Service classes:</p>

<p>➜ k get pods -n project-c13 \</p>

<p>-o jsonpath="{range .items[*]}{.metadata.name} {.status.qosClass}{'\n'}"</p>

<p>c13-2x3-api-86784557bd-cgs8g Burstable</p>

<p>c13-2x3-api-86784557bd-lnxvj Burstable</p>

<p>c13-2x3-api-86784557bd-mnp77 Burstable</p>

<p>c13-2x3-web-769c989898-6hbgt Burstable</p>

<p>c13-2x3-web-769c989898-g57nq Burstable</p>

<p>c13-2x3-web-769c989898-hfd5v Burstable</p>

<p>c13-2x3-web-769c989898-jfx64 Burstable</p>

<p>c13-2x3-web-769c989898-r89mg Burstable</p>

<p>c13-2x3-web-769c989898-wtgxl Burstable</p>

<p>c13-3cc-runner-98c8b5469-dzqhr Burstable</p>

<p>c13-3cc-runner-98c8b5469-hbtdv Burstable</p>

<p>c13-3cc-runner-98c8b5469-n9lsw Burstable</p>

<p>c13-3cc-runner-heavy-65588d7d6-djtv9 BestEffort</p>

<p>c13-3cc-runner-heavy-65588d7d6-v8kf5 BestEffort</p>

<p>c13-3cc-runner-heavy-65588d7d6-wwpb4 BestEffort</p>

<p>c13-3cc-web-675456bcd-glpq6 Burstable</p>

<p>c13-3cc-web-675456bcd-knlpx Burstable</p>

<p>c13-3cc-web-675456bcd-nfhp9 Burstable</p>

<p>c13-3cc-web-675456bcd-twn7m Burstable</p>

<p>o3db-0 BestEffort</p>

<p>o3db-1 BestEffort</p>

<p>Here we see three with BestEffort, which <em>Pods</em> get that don't have any memory or cpu limits or requests defined.</p>

<p>A good practice is to always set resource requests and limits. If you don't know the values your containers should have you can find this out using metric tools like Prometheus. You can also use kubectl top pod or even kubectl exec into the container and use top and similar tools.</p>

<p> </p>

<p> </p>

<p><strong>Extra Question 2 | Curl Manually Contact API</strong></p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>There is an existing <em>ServiceAccount</em> secret-reader in <em>Namespace</em> project-hamster. Create a <em>Pod</em> of image curlimages/curl:7.65.3 named tmp-api-contact which uses this <em>ServiceAccount</em>. Make sure the container keeps running.</p>

<p>Exec into the <em>Pod</em> and use curl to access the Kubernetes Api of that cluster manually, listing all available secrets. You can ignore insecure https connection. Write the command(s) for this into file /opt/course/e4/list-secrets.sh.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><a href="https://kubernetes.io/docs/tasks/run-application/access-api-from-pod">[https://kubernetes.io/docs/tasks/run-application/access-api-from-pod]{.underline}</a></p>

<p>It's important to understand how the Kubernetes API works. For this it helps connecting to the api manually, for example using curl. You can find information fast by search in the Kubernetes docs for "curl api" for example.</p>

<p>First we create our <em>Pod</em>:</p>

<p>k run tmp-api-contact \</p>

<p>--image=curlimages/curl:7.65.3 $do \</p>

<p>--command &gt; e2.yaml -- sh -c 'sleep 1d'</p>

<p>vim e2.yaml</p>

<p>Add the service account name and <em>Namespace</em>:</p>

<p># e2.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: tmp-api-contact</p>

<p>name: tmp-api-contact</p>

<p>namespace: project-hamster # add</p>

<p>spec:</p>

<p>serviceAccountName: secret-reader # add</p>

<p>containers:</p>

<p>- command:</p>

<p>  - sh</p>

<p>  - -c</p>

<p>  - sleep 1d</p>

<p>  image: curlimages/curl:7.65.3</p>

<p>  name: tmp-api-contact</p>

<p>  resources: {}</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p>Then run and exec into:</p>

<p>k -f 6.yaml create</p>

<p>k -n project-hamster exec tmp-api-contact -it -- sh</p>

<p>Once on the container we can try to connect to the api using curl, the api is usually available via the <em>Service</em> named kubernetes in <em>Namespace</em> default (You should know how dns resolution works across <em>Namespaces</em>.). Else we can find the endpoint IP via environment variables running env.</p>

<p>So now we can do:</p>

<p>curl https://kubernetes.default</p>

<p>curl -k https://kubernetes.default # ignore insecure as allowed in ticket description</p>

<p>curl -k https://kubernetes.default/api/v1/secrets # should show Forbidden 403</p>

<p>The last command shows 403 forbidden, this is because we are not passing any authorisation information with us. The Kubernetes Api Server thinks we are connecting as system:anonymous. We want to change this and connect using the <em>Pods</em> <em>ServiceAccount</em> named secret-reader.</p>

<p>We find the the token in the mounted folder at /var/run/secrets/kubernetes.io/serviceaccount, so we do:</p>

<p>➜ TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)</p>

<p>➜ curl -k https://kubernetes.default/api/v1/secrets -H "Authorization: Bearer ${TOKEN}"</p>

<p>\% Total   % Received % Xferd Average Speed   Time   Time     Time Current</p>

<p>                                Dload Upload   Total   Spent   Left Speed</p>

<p>0     0   0     0   0     0     0     0 --:--:-- --:--:-- --:--:--     0{</p>

<p>"kind": "SecretList",</p>

<p>"apiVersion": "v1",</p>

<p>"metadata": {</p>

<p>  "selfLink": "/api/v1/secrets",</p>

<p>  "resourceVersion": "10697"</p>

<p>},</p>

<p>"items": [</p>

<p>  {</p>

<p>    "metadata": {</p>

<p>      "name": "default-token-5zjbd",</p>

<p>      "namespace": "default",</p>

<p>      "selfLink": "/api/v1/namespaces/default/secrets/default-token-5zjbd",</p>

<p>      "uid": "315dbfd9-d235-482b-8bfc-c6167e7c1461",</p>

<p>      "resourceVersion": "342",</p>

<p>...</p>

<p>Now we're able to list all <em>Secrets</em>, registering as the <em>ServiceAccount</em> secret-reader under which our <em>Pod</em> is running.</p>

<p>To use encrypted https connection we can run:</p>

<p>CACERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</p>

<p>curl --cacert ${CACERT} https://kubernetes.default/api/v1/secrets -H "Authorization: Bearer ${TOKEN}"</p>

<p>For troubleshooting we could also check if the <em>ServiceAccount</em> is actually able to list <em>Secrets</em> using:</p>

<p>➜ k auth can-i get secret --as system:serviceaccount:project-hamster:secret-reader</p>

<p>yes</p>

<p>Finally write the commands into the requested location:</p>

<p># /opt/course/e4/list-secrets.sh</p>

<p>TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)</p>

<p>curl -k https://kubernetes.default/api/v1/secrets -H "Authorization: Bearer ${TOKEN}"</p>

<p> </p>

<p> </p>

<p><strong>CKA Simulator Preview Kubernetes 1.29</strong></p>

<p><a href="https://killer.sh/">[https://killer.sh]{.underline}</a></p>

<p>This is a preview of the full CKA Simulator course content.</p>

<p>The full course contains 25 scenarios from all the CKA areas. The course also provides a browser terminal which is a very close replica of the original one. This is great to get used and comfortable before the real exam. After the test session (120 minutes), or if you stop it early, you'll get access to all questions and their detailed solutions. You'll have 36 hours cluster access in total which means even after the session, once you have the solutions, you can still play around.</p>

<p>The following preview will give you an idea of what the full course will provide. These preview questions are in addition to the 25 of the full course. But the preview questions are part of the same CKA simulation environment which we setup for you, so with access to the full course you can solve these too.</p>

<p>The answers provided here assume that you did run the initial terminal setup suggestions as provided in the tips section, but especially:</p>

<p>alias k=kubectl</p>

<p>export do="-o yaml --dry-run=client"</p>

<p> </p>

<p><strong>These questions can be solved in the test environment provided through the CKA Simulator</strong></p>

<p> </p>

<p><strong>Preview Question 1</strong></p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p>The cluster admin asked you to find out the following information about etcd running on cluster2-controlplane1:</p>

<ul>
  <li>
    <p>Server private key location</p>
  </li>
  <li>
    <p>Server certificate expiration date</p>
  </li>
  <li>
    <p>Is client certificate authentication enabled</p>
  </li>
</ul>

<p>Write these information into /opt/course/p1/etcd-info.txt</p>

<p>Finally you're asked to save an etcd snapshot at /etc/etcd-snapshot.db on cluster2-controlplane1 and display its status.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Find out etcd information</strong></p>

<p>Let's check the nodes:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster2-controlplane1   Ready   control-plane   89m   v1.29.0</p>

<p>cluster2-node1           Ready   &lt;none&gt;         87m   v1.29.0</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>First we check how etcd is setup in this cluster:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod</p>

<p>NAME                                               READY   STATUS   RESTARTS   AGE</p>

<p>coredns-66bff467f8-k8f48                           1/1     Running   0         26h</p>

<p>coredns-66bff467f8-rn8tr                           1/1     Running   0         26h</p>

<p>etcd-cluster2-controlplane1                         1/1     Running   0         26h</p>

<p>kube-apiserver-cluster2-controlplane1               1/1     Running   0         26h</p>

<p>kube-controller-manager-cluster2-controlplane1     1/1     Running   0         26h</p>

<p>kube-proxy-qthfg                                   1/1     Running   0         25h</p>

<p>kube-proxy-z55lp                                   1/1     Running   0         26h</p>

<p>kube-scheduler-cluster2-controlplane1               1/1     Running   1         26h</p>

<p>weave-net-cqdvt                                     2/2     Running   0         26h</p>

<p>weave-net-dxzgh                                     2/2     Running   1         25h</p>

<p>We see it's running as a <em>Pod</em>, more specific a static <em>Pod</em>. So we check for the default kubelet directory for static manifests:</p>

<p>➜ root@cluster2-controlplane1:~# find /etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/</p>

<p>/etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p>/etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p>/etc/kubernetes/manifests/etcd.yaml</p>

<p>/etc/kubernetes/manifests/kube-scheduler.yaml</p>

<p>➜ root@cluster2-controlplane1:~# vim /etc/kubernetes/manifests/etcd.yaml</p>

<p>So we look at the yaml and the parameters with which etcd is started:</p>

<p># /etc/kubernetes/manifests/etcd.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: etcd</p>

<p>  tier: control-plane</p>

<p>name: etcd</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - etcd</p>

<p>  - --advertise-client-urls=https://192.168.102.11:2379</p>

<p>  - --cert-file=/etc/kubernetes/pki/etcd/server.crt              # server certificate</p>

<p>  - --client-cert-auth=true                                      # enabled</p>

<p>  - --data-dir=/var/lib/etcd</p>

<p>  - --initial-advertise-peer-urls=https://192.168.102.11:2380</p>

<p>  - --initial-cluster=cluster2-controlplane1=https://192.168.102.11:2380</p>

<p>  - --key-file=/etc/kubernetes/pki/etcd/server.key               # server private key</p>

<p>  - --listen-client-urls=https://127.0.0.1:2379,https://192.168.102.11:2379</p>

<p>  - --listen-metrics-urls=http://127.0.0.1:2381</p>

<p>  - --listen-peer-urls=https://192.168.102.11:2380</p>

<p>  - --name=cluster2-controlplane1</p>

<p>  - --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt</p>

<p>  - --peer-client-cert-auth=true</p>

<p>  - --peer-key-file=/etc/kubernetes/pki/etcd/peer.key</p>

<p>  - --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>  - --snapshot-count=10000</p>

<p>  - --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</p>

<p>...</p>

<p>We see that client authentication is enabled and also the requested path to the server private key, now let's find out the expiration of the server certificate:</p>

<p>➜ root@cluster2-controlplane1:~# openssl x509 -noout -text -in /etc/kubernetes/pki/etcd/server.crt | grep Validity -A2</p>

<p>      Validity</p>

<p>          Not Before: Sep 13 13:01:31 2021 GMT</p>

<p>          Not After : Sep 13 13:01:31 2022 GMT</p>

<p>There we have it. Let's write the information into the requested file:</p>

<p># /opt/course/p1/etcd-info.txt</p>

<p>Server private key location: /etc/kubernetes/pki/etcd/server.key</p>

<p>Server certificate expiration date: Sep 13 13:01:31 2022 GMT</p>

<p>Is client certificate authentication enabled: yes</p>

<p> </p>

<p><strong>Create etcd snapshot</strong></p>

<p>First we try:</p>

<p>ETCDCTL_API=3 etcdctl snapshot save /etc/etcd-snapshot.db</p>

<p>We get the endpoint also from the yaml. But we need to specify more parameters, all of which we can find the yaml declaration above:</p>

<p>ETCDCTL_API=3 etcdctl snapshot save /etc/etcd-snapshot.db \</p>

<p>--cacert /etc/kubernetes/pki/etcd/ca.crt \</p>

<p>--cert /etc/kubernetes/pki/etcd/server.crt \</p>

<p>--key /etc/kubernetes/pki/etcd/server.key</p>

<p>This worked. Now we can output the status of the backup file:</p>

<p>➜ root@cluster2-controlplane1:~# ETCDCTL_API=3 etcdctl snapshot status /etc/etcd-snapshot.db</p>

<p>4d4e953, 7213, 1291, 2.7 MB</p>

<p>The status shows:</p>

<ul>
  <li>
    <p>Hash: 4d4e953</p>
  </li>
  <li>
    <p>Revision: 7213</p>
  </li>
  <li>
    <p>Total Keys: 1291</p>
  </li>
  <li>
    <p>Total Size: 2.7 MB</p>
  </li>
</ul>

<p> </p>

<p> </p>

<p><strong>Preview Question 2</strong></p>

<p>Use context: kubectl config use-context k8s-c1-H</p>

<p> </p>

<p>You're asked to confirm that kube-proxy is running correctly on all nodes. For this perform the following in <em>Namespace</em> project-hamster:</p>

<p>Create a new <em>Pod</em> named p2-pod with two containers, one of image nginx:1.21.3-alpine and one of image busybox:1.31. Make sure the busybox container keeps running for some time.</p>

<p>Create a new <em>Service</em> named p2-service which exposes that <em>Pod</em> internally in the cluster on port 3000-&gt;80.</p>

<p>Find the kube-proxy container on all nodes cluster1-controlplane1, cluster1-node1 and cluster1-node2 and make sure that it's using iptables. Use command crictl for this.</p>

<p>Write the iptables rules of all nodes belonging the created <em>Service</em> p2-service into file /opt/course/p2/iptables.txt.</p>

<p>Finally delete the <em>Service</em> and confirm that the iptables rules are gone from all nodes.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p><strong>Create the <em>Pod</em></strong></p>

<p>First we create the <em>Pod</em>:</p>

<p># check out export statement on top which allows us to use $do</p>

<p>k run p2-pod --image=nginx:1.21.3-alpine $do &gt; p2.yaml</p>

<p>vim p2.yaml</p>

<p>Next we add the requested second container:</p>

<p># p2.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  run: p2-pod</p>

<p>name: p2-pod</p>

<p>namespace: project-hamster             # add</p>

<p>spec:</p>

<p>containers:</p>

<p>- image: nginx:1.21.3-alpine</p>

<p>  name: p2-pod</p>

<p>- image: busybox:1.31                  # add</p>

<p>  name: c2                             # add</p>

<p>  command: ["sh", "-c", "sleep 1d"]    # add</p>

<p>  resources: {}</p>

<p>dnsPolicy: ClusterFirst</p>

<p>restartPolicy: Always</p>

<p>status: {}</p>

<p>And we create the <em>Pod</em>:</p>

<p>k -f p2.yaml create</p>

<p> </p>

<p><strong>Create the <em>Service</em></strong></p>

<p>Next we create the <em>Service</em>:</p>

<p>k -n project-hamster expose pod p2-pod --name p2-service --port 3000 --target-port 80</p>

<p>This will create a yaml like:</p>

<p>apiVersion: v1</p>

<p>kind: Service</p>

<p>metadata:</p>

<p>creationTimestamp: "2020-04-30T20:58:14Z"</p>

<p>labels:</p>

<p>  run: p2-pod</p>

<p>managedFields:</p>

<p>...</p>

<p>  operation: Update</p>

<p>  time: "2020-04-30T20:58:14Z"</p>

<p>name: p2-service</p>

<p>namespace: project-hamster</p>

<p>resourceVersion: "11071"</p>

<p>selfLink: /api/v1/namespaces/project-hamster/services/p2-service</p>

<p>uid: 2a1c0842-7fb6-4e94-8cdb-1602a3b1e7d2</p>

<p>spec:</p>

<p>clusterIP: 10.97.45.18</p>

<p>ports:</p>

<p>- port: 3000</p>

<p>  protocol: TCP</p>

<p>  targetPort: 80</p>

<p>selector:</p>

<p>  run: p2-pod</p>

<p>sessionAffinity: None</p>

<p>type: ClusterIP</p>

<p>status:</p>

<p>loadBalancer: {}</p>

<p>We should confirm <em>Pods</em> and <em>Services</em> are connected, hence the <em>Service</em> should have <em>Endpoints</em>.</p>

<p>k -n project-hamster get pod,svc,ep</p>

<p> </p>

<p><strong>Confirm kube-proxy is running and is using iptables</strong></p>

<p>First we get nodes in the cluster:</p>

<p>➜ k get node</p>

<p>NAME                     STATUS   ROLES           AGE   VERSION</p>

<p>cluster1-controlplane1   Ready   control-plane   98m   v1.29.0</p>

<p>cluster1-node1           Ready   &lt;none&gt;         96m   v1.29.0</p>

<p>cluster1-node2           Ready   &lt;none&gt;         95m   v1.29.0</p>

<p>The idea here is to log into every node, find the kube-proxy container and check its logs:</p>

<p>➜ ssh cluster1-controlplane1</p>

<p>➜ root@cluster1-controlplane1$ crictl ps | grep kube-proxy</p>

<p>27b6a18c0f89c       36c4ebbc9d979       3 hours ago         Running             kube-proxy</p>

<p>➜ root@cluster1-controlplane1~# crictl logs 27b6a18c0f89c</p>

<p>...</p>

<p>I0913 12:53:03.096620       1 server_others.go:212] Using iptables Proxier.</p>

<p>...</p>

<p>This should be repeated on every node and result in the same output Using iptables Proxier.</p>

<p> </p>

<p><strong>Check kube-proxy is creating iptables rules</strong></p>

<p>Now we check the iptables rules on every node first manually:</p>

<p>➜ ssh cluster1-controlplane1 iptables-save | grep p2-service</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -s 10.44.0.20/32 -m comment --comment "project-hamster/p2-service:" -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -p tcp -m comment --comment "project-hamster/p2-service:" -m tcp -j DNAT --to-destination 10.44.0.20:80</p>

<p>-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SERVICES -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-SVC-2A6FNMCK6FDH7PJH</p>

<p>-A KUBE-SVC-2A6FNMCK6FDH7PJH -m comment --comment "project-hamster/p2-service:" -j KUBE-SEP-6U447UXLLQIKP7BB</p>

<p>➜ ssh cluster1-node1 iptables-save | grep p2-service</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -s 10.44.0.20/32 -m comment --comment "project-hamster/p2-service:" -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -p tcp -m comment --comment "project-hamster/p2-service:" -m tcp -j DNAT --to-destination 10.44.0.20:80</p>

<p>-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SERVICES -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-SVC-2A6FNMCK6FDH7PJH</p>

<p>-A KUBE-SVC-2A6FNMCK6FDH7PJH -m comment --comment "project-hamster/p2-service:" -j KUBE-SEP-6U447UXLLQIKP7BB</p>

<p>➜ ssh cluster1-node2 iptables-save | grep p2-service</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -s 10.44.0.20/32 -m comment --comment "project-hamster/p2-service:" -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SEP-6U447UXLLQIKP7BB -p tcp -m comment --comment "project-hamster/p2-service:" -m tcp -j DNAT --to-destination 10.44.0.20:80</p>

<p>-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-MARK-MASQ</p>

<p>-A KUBE-SERVICES -d 10.97.45.18/32 -p tcp -m comment --comment "project-hamster/p2-service: cluster IP" -m tcp --dport 3000 -j KUBE-SVC-2A6FNMCK6FDH7PJH</p>

<p>-A KUBE-SVC-2A6FNMCK6FDH7PJH -m comment --comment "project-hamster/p2-service:" -j KUBE-SEP-6U447UXLLQIKP7BB</p>

<p>Great. Now let's write these logs into the requested file:</p>

<p>➜ ssh cluster1-controlplane1 iptables-save | grep p2-service &gt;&gt; /opt/course/p2/iptables.txt</p>

<p>➜ ssh cluster1-node1 iptables-save | grep p2-service &gt;&gt; /opt/course/p2/iptables.txt</p>

<p>➜ ssh cluster1-node2 iptables-save | grep p2-service &gt;&gt; /opt/course/p2/iptables.txt</p>

<p> </p>

<p><strong>Delete the <em>Service</em> and confirm iptables rules are gone</strong></p>

<p>Delete the <em>Service</em>:</p>

<p>k -n project-hamster delete svc p2-service</p>

<p>And confirm the iptables rules are gone:</p>

<p>➜ ssh cluster1-controlplane1 iptables-save | grep p2-service</p>

<p>➜ ssh cluster1-node1 iptables-save | grep p2-service</p>

<p>➜ ssh cluster1-node2 iptables-save | grep p2-service</p>

<p>Done.</p>

<p>Kubernetes <em>Services</em> are implemented using iptables rules (with default config) on all nodes. Every time a <em>Service</em> has been altered, created, deleted or <em>Endpoints</em> of a <em>Service</em> have changed, the kube-apiserver contacts every node's kube-proxy to update the iptables rules according to the current state.</p>

<p> </p>

<p> </p>

<p><strong>Preview Question 3</strong></p>

<p>Use context: kubectl config use-context k8s-c2-AC</p>

<p> </p>

<p>Create a <em>Pod</em> named check-ip in <em>Namespace</em> default using image httpd:2.4.41-alpine. Expose it on port 80 as a ClusterIP <em>Service</em> named check-ip-service. Remember/output the IP of that <em>Service</em>.</p>

<p>Change the Service CIDR to 11.96.0.0/12 for the cluster.</p>

<p>Then create a second <em>Service</em> named check-ip-service2 pointing to the same <em>Pod</em> to check if your settings did take effect. Finally check if the IP of the first <em>Service</em> has changed.</p>

<p> </p>

<p><strong>Answer:</strong></p>

<p>Let's create the <em>Pod</em> and expose it:</p>

<p>k run check-ip --image=httpd:2.4.41-alpine</p>

<p>k expose pod check-ip --name check-ip-service --port 80</p>

<p>And check the <em>Pod</em> and <em>Service</em> ips:</p>

<p>➜ k get svc,ep -l run=check-ip</p>

<p>NAME                       TYPE       CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</p>

<p>service/check-ip-service   ClusterIP   10.104.3.45   &lt;none&gt;       80/TCP   8s</p>

<p>NAME                         ENDPOINTS     AGE</p>

<p>endpoints/check-ip-service   10.44.0.3:80   7s</p>

<p>Now we change the <em>Service</em> CIDR on the kube-apiserver:</p>

<p>➜ ssh cluster2-controlplane1</p>

<p>➜ root@cluster2-controlplane1:~# vim /etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p># /etc/kubernetes/manifests/kube-apiserver.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: kube-apiserver</p>

<p>  tier: control-plane</p>

<p>name: kube-apiserver</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - kube-apiserver</p>

<p>  - --advertise-address=192.168.100.21</p>

<p>...</p>

<p>  - --service-account-key-file=/etc/kubernetes/pki/sa.pub</p>

<p>  - --service-cluster-ip-range=11.96.0.0/12 # change</p>

<p>  - --tls-cert-file=/etc/kubernetes/pki/apiserver.crt</p>

<p>  - --tls-private-key-file=/etc/kubernetes/pki/apiserver.key</p>

<p>...</p>

<p><strong>Give it a bit for the kube-apiserver and controller-manager to restart</strong></p>

<p>Wait for the api to be up again:</p>

<p>➜ root@cluster2-controlplane1:~# kubectl -n kube-system get pod | grep api</p>

<p>kube-apiserver-cluster2-controlplane1           1/1     Running   0             49s</p>

<p> </p>

<p> </p>

<p>Now we do the same for the controller manager:</p>

<p>➜ root@cluster2-controlplane1:~# vim /etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p># /etc/kubernetes/manifests/kube-controller-manager.yaml</p>

<p>apiVersion: v1</p>

<p>kind: Pod</p>

<p>metadata:</p>

<p>creationTimestamp: null</p>

<p>labels:</p>

<p>  component: kube-controller-manager</p>

<p>  tier: control-plane</p>

<p>name: kube-controller-manager</p>

<p>namespace: kube-system</p>

<p>spec:</p>

<p>containers:</p>

<p>- command:</p>

<p>  - kube-controller-manager</p>

<p>  - --allocate-node-cidrs=true</p>

<p>  - --authentication-kubeconfig=/etc/kubernetes/controller-manager.conf</p>

<p>  - --authorization-kubeconfig=/etc/kubernetes/controller-manager.conf</p>

<p>  - --bind-address=127.0.0.1</p>

<p>  - --client-ca-file=/etc/kubernetes/pki/ca.crt</p>

<p>  - --cluster-cidr=10.244.0.0/16</p>

<p>  - --cluster-name=kubernetes</p>

<p>  - --cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt</p>

<p>  - --cluster-signing-key-file=/etc/kubernetes/pki/ca.key</p>

<p>  - --controllers=*,bootstrapsigner,tokencleaner</p>

<p>  - --kubeconfig=/etc/kubernetes/controller-manager.conf</p>

<p>  - --leader-elect=true</p>

<p>  - --node-cidr-mask-size=24</p>

<p>  - --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt</p>

<p>  - --root-ca-file=/etc/kubernetes/pki/ca.crt</p>

<p>  - --service-account-private-key-file=/etc/kubernetes/pki/sa.key</p>

<p>  - --service-cluster-ip-range=11.96.0.0/12 # change</p>

<p>  - --use-service-account-credentials=true</p>

<p><strong>Give it a bit for the scheduler to restart</strong>.</p>

<p>We can check if it was restarted using crictl:</p>

<p>➜ root@cluster2-controlplane1:~# crictl ps | grep scheduler</p>

<p>3d258934b9fd6   aca5ededae9c8   About a minute ago   Running   kube-scheduler ...</p>

<p> </p>

<p> </p>

<p>Checking our existing <em>Pod</em> and <em>Service</em> again:</p>

<p>➜ k get pod,svc -l run=check-ip</p>

<p>NAME           READY   STATUS   RESTARTS   AGE</p>

<p>pod/check-ip   1/1     Running   0         21m</p>

<p>NAME                       TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</p>

<p>service/check-ip-service   ClusterIP   10.99.32.177   &lt;none&gt;       80/TCP   21m</p>

<p>Nothing changed so far. Now we create another <em>Service</em> like before:</p>

<p>k expose pod check-ip --name check-ip-service2 --port 80</p>

<p>And check again:</p>

<p>➜ k get svc,ep -l run=check-ip</p>

<p>NAME                       TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</p>

<p>service/check-ip-service   ClusterIP   10.109.222.111   &lt;none&gt;       80/TCP   8m</p>

<p>service/check-ip-service2   ClusterIP   11.111.108.194   &lt;none&gt;       80/TCP   6m32s</p>

<p>NAME                         ENDPOINTS     AGE</p>

<p>endpoints/check-ip-service   10.44.0.1:80   8m</p>

<p>endpoints/check-ip-service2   10.44.0.1:80   6m13s</p>

<p>There we go, the new <em>Service</em> got an ip of the new specified range assigned. We also see that both <em>Services</em> have our <em>Pod</em> as endpoint.</p>

<p> </p>

<p><strong>CKA Tips Kubernetes 1.29</strong></p>

<p>In this section we'll provide some tips on how to handle the CKA exam and browser terminal.</p>

<p> </p>

<p><strong>Knowledge</strong></p>

<p>Study all topics as proposed in the curriculum till you feel comfortable with all.</p>

<p> </p>

<p><strong>General</strong></p>

<ul>
  <li>
    <p>Study all topics as proposed in the curriculum till you feel comfortable with all</p>
  </li>
  <li>
    <p>Do 1 or 2 test session with this CKA Simulator. Understand the solutions and maybe try out other ways to achieve the same thing.</p>
  </li>
  <li>
    <p>Setup your aliases, be fast and breath kubectl</p>
  </li>
  <li>
    <p>The majority of tasks in the CKA will also be around creating Kubernetes resources, like it's tested in the CKAD. So preparing a bit for the CKAD can't hurt.</p>
  </li>
  <li>
    <p>Learn and Study the in-browser scenarios on <a href="https://killercoda.com/killer-shell-cka">[https://killercoda.com/killer-shell-cka]{.underline}</a> (and maybe for CKAD <a href="https://killercoda.com/killer-shell-ckad">[https://killercoda.com/killer-shell-ckad]{.underline}</a>)</p>
  </li>
  <li>
    <p>Imagine and create your own scenarios to solve</p>
  </li>
</ul>

<p> </p>

<p><strong>Components</strong></p>

<ul>
  <li>
    <p>Understanding Kubernetes components and being able to fix and investigate clusters: <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster">[https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster]{.underline}</a></p>
  </li>
  <li>
    <p>Know advanced scheduling: <a href="https://kubernetes.io/docs/concepts/scheduling/kube-scheduler">[https://kubernetes.io/docs/concepts/scheduling/kube-scheduler]{.underline}</a></p>
  </li>
  <li>
    <p>When you have to fix a component (like kubelet) in one cluster, just check how it's setup on another node in the same or even another cluster. You can copy config files over etc</p>
  </li>
  <li>
    <p>If you like you can look at <a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">[Kubernetes The Hard Way]{.underline}</a> once. But it's NOT necessary to do, the CKA is not that complex. But KTHW helps understanding the concepts</p>
  </li>
  <li>
    <p>You should install your own cluster using kubeadm (one controlplane, one worker) in a VM or using a cloud provider and investigate the components</p>
  </li>
  <li>
    <p>Know how to use Kubeadm to for example add nodes to a cluster</p>
  </li>
  <li>
    <p>Know how to create an Ingress resources</p>
  </li>
  <li>
    <p>Know how to snapshot/restore ETCD from another machine</p>
  </li>
</ul>

<p> </p>

<p> </p>

<p><strong>CKA Preparation</strong></p>

<p><strong>Read the Curriculum</strong></p>

<p><a href="https://github.com/cncf/curriculum">[https://github.com/cncf/curriculum]{.underline}</a></p>

<p><strong>Read the Handbook</strong></p>

<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/lf-handbook2">[https://docs.linuxfoundation.org/tc-docs/certification/lf-handbook2]{.underline}</a></p>

<p><strong>Read the important tips</strong></p>

<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad">[https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad]{.underline}</a></p>

<p><strong>Read the FAQ</strong></p>

<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad">[https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad]{.underline}</a></p>

<p> </p>

<p><strong>Kubernetes documentation</strong></p>

<p>Get familiar with the Kubernetes documentation and be able to use the search. Allowed links are:</p>

<ul>
  <li>
    <p><a href="https://kubernetes.io/docs">[https://kubernetes.io/docs]{.underline}</a></p>
  </li>
  <li>
    <p><a href="https://kubernetes.io/blog">[https://kubernetes.io/blog]{.underline}</a></p>
  </li>
  <li>
    <p><a href="https://helm.sh/docs">[https://helm.sh/docs]{.underline}</a></p>
  </li>
</ul>

<p><strong><em>NOTE:</em></strong> Verify the list <a href="https://docs.linuxfoundation.org/tc-docs/certification/certification-resources-allowed#certified-kubernetes-administrator-cka-and-certified-kubernetes-application-developer-ckad">[here]{.underline}</a></p>

<p> </p>

<p><strong>The Test Environment / Browser Terminal</strong></p>

<p>You'll be provided with a browser terminal which uses Ubuntu 20. The standard shells included with a minimal install of Ubuntu 20 will be available, including bash.</p>

<p><strong>Laggin</strong></p>

<p>There could be some lagging, definitely make sure you are using a good internet connection because your webcam and screen are uploading all the time.</p>

<p><strong>Kubectl autocompletion and commands</strong></p>

<p>Autocompletion is configured by default, as well as the k alias <a href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad">[source]{.underline}</a> and others:</p>

<p>kubectl with k alias and Bash autocompletion</p>

<p>yq and jqfor YAML/JSON processing</p>

<p>tmux for terminal multiplexing</p>

<p>curl and wget for testing web services</p>

<p>man and man pages for further documentation</p>

<p><strong>Copy &amp; Paste</strong></p>

<p>There could be issues copying text (like pod names) from the left task information into the terminal. Some suggested to "hard" hit or long hold Cmd/Ctrl+C a few times to take action. Apart from that copy and paste should just work like in normal terminals.</p>

<p><strong>Score</strong></p>

<p>There are 15-20 questions in the exam. Your results will be automatically checked according to the handbook. If you don't agree with the results you can request a review by contacting the Linux Foundation Support.</p>

<p><strong>Notepad &amp; Skipping Questions</strong></p>

<p>You have access to a simple notepad in the browser which can be used for storing any kind of plain text. It might makes sense to use this for saving skipped question numbers. This way it's possible to move some questions to the end.</p>

<p><strong>Contexts</strong></p>

<p>You'll receive access to various different clusters and resources in each. They provide you the exact command you need to run to connect to another cluster/context. But you should be comfortable working in different namespaces with kubectl.</p>

<p> </p>

<p><strong>PSI Bridge</strong></p>

<p>Starting with <a href="https://training.linuxfoundation.org/bridge-migration-2021">[PSI Bridge]{.underline}</a>:</p>

<ul>
  <li>
    <p>The exam will now be taken using the PSI Secure Browser, which can be downloaded using the newest versions of Microsoft Edge, Safari, Chrome, or Firefox</p>
  </li>
  <li>
    <p>Multiple monitors will no longer be permitted</p>
  </li>
  <li>
    <p>Use of personal bookmarks will no longer be permitted</p>
  </li>
</ul>

<p>The new ExamUI includes improved features such as:</p>

<ul>
  <li>
    <p>A remote desktop configured with the tools and software needed to complete the tasks</p>
  </li>
  <li>
    <p>A timer that displays the actual time remaining (in minutes) and provides an alert with 30, 15, or 5 minute remaining</p>
  </li>
  <li>
    <p>The content panel remains the same (presented on the Left Hand Side of the ExamUI)</p>
  </li>
</ul>

<p>Read more <a href="https://training.linuxfoundation.org/bridge-migration-2021">[here]{.underline}</a>.</p>

<p> </p>

<p><strong>Browser Terminal Setup</strong></p>

<p>It should be considered to spend ~1 minute in the beginning to setup your terminal. In the real exam the vast majority of questions will be done from the main terminal. For few you might need to ssh into another machine. Just be aware that configurations to your shell will not be transferred in this case.</p>

<p><strong>Minimal Setup</strong></p>

<p><strong>Alias</strong></p>

<p>The alias k for kubectl will already be configured together with autocompletion. In case not you can configure it using this <a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet">[link]{.underline}</a>.</p>

<p><strong>Vim</strong></p>

<p>The following settings will already be configured in your real exam environment in ~/.vimrc. But it can never hurt to be able to type these down:</p>

<p>set tabstop=2</p>

<p>set expandtab</p>

<p>set shiftwidth=2</p>

<p>The expandtab make sure to use spaces for tabs. Memorize these and just type them down. You can't have any written notes with commands on your desktop etc.</p>

<p><strong>Optional Setup</strong></p>

<p><strong>Fast dry-run output</strong></p>

<p>export do="--dry-run=client -o yaml"</p>

<p>This way you can just run k run pod1 --image=nginx $do. Short for "dry output", but use whatever name you like.</p>

<p><strong>Fast pod delete</strong></p>

<p>export now="--force --grace-period 0"</p>

<p>This way you can run k delete pod1 $now and don't have to wait for ~30 seconds termination time.</p>

<p><strong>Persist bash settings</strong></p>

<p>You can store aliases and other setup in ~/.bashrc if you're planning on using different shells or tmux.</p>

<p><strong>Alias Namespace</strong></p>

<p>In addition you could define an alias like:</p>

<p>alias kn='kubectl config set-context --current --namespace '</p>

<p>Which allows you to define the default namespace of the current context. Then once you switch a context or namespace you can just run:</p>

<p>kn default        # set default to default</p>

<p>kn my-namespace   # set default to my-namespace</p>

<p>But only do this if you used it before and are comfortable doing so. Else you need to specify the namespace for every call, which is also fine:</p>

<p>k -n my-namespace get all</p>

<p>k -n my-namespace get pod</p>

<p>...</p>

<p> </p>

<p><strong>Be fast</strong></p>

<p>Use the history command to reuse already entered commands or use even faster history search through <strong>Ctrl r </strong>.</p>

<p>If a command takes some time to execute, like sometimes kubectl delete pod x. You can put a task in the background using <strong>Ctrl z</strong> and pull it back into foreground running command fg.</p>

<p>You can delete <em>pods</em> fast with:</p>

<p>k delete pod x --grace-period 0 --force</p>

<p>k delete pod x $now # if export from above is configured</p>

<p> </p>

<p><strong>Vim</strong></p>

<p>Be great with vim.</p>

<p><strong>toggle vim line numbers</strong></p>

<p>When in vim you can press <strong>Esc</strong> and type :set number or :set nonumber followed by <strong>Enter</strong> to toggle line numbers. This can be useful when finding syntax errors based on line - but can be bad when wanting to mark&amp;copy by mouse. You can also just jump to a line number with <strong>Esc</strong> :22 + <strong>Enter</strong>.</p>

<p><strong>copy&amp;paste</strong></p>

<p>Get used to copy/paste/cut with vim:</p>

<p>Mark lines: Esc+V (then arrow keys)</p>

<p>Copy marked lines: y</p>

<p>Cut marked lines: d</p>

<p>Past lines: p or P</p>

<p><strong>Indent multiple lines</strong></p>

<p>To indent multiple lines press <strong>Esc</strong> and type :set shiftwidth=2. First mark multiple lines using Shift v and the up/down keys. Then to indent the marked lines press &gt; or &lt;. You can then press . to repeat the action.</p>

<p> </p>

<p><strong>Split terminal screen</strong></p>

<p>By default tmux is installed and can be used to split your one terminal into multiple. <strong>But</strong> just do this if you know your shit, because scrolling is different and copy&amp;pasting might be weird.</p>

<p><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux">[https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux]{.underline}</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[author: Vitalie Procopan date: 2024-06-09 09:25:00 changed: 2024-06-09 09:26:00 —]]></summary></entry><entry><title type="html">Welcome to my blog, here are some tips and tricks</title><link href="http://localhost:4000/2024/01/01/vscode-tips-and-tricks.html" rel="alternate" type="text/html" title="Welcome to my blog, here are some tips and tricks" /><published>2024-01-01T00:00:00+02:00</published><updated>2024-01-01T00:00:00+02:00</updated><id>http://localhost:4000/2024/01/01/vscode-tips-and-tricks</id><content type="html" xml:base="http://localhost:4000/2024/01/01/vscode-tips-and-tricks.html"><![CDATA[<h1 id="welcome">Welcome</h1>

<p><strong>Hello world</strong>, <a href="https://github.com/Microsoft/vscode-tips-and-tricks">https://github.com/Microsoft/vscode-docs/blob/main/docs/getstarted/tips-and-tricks.md</a></p>

<p>I hope you like it!</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Welcome]]></summary></entry></feed>